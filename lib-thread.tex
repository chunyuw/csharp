%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn> %% $Rev$

\section{多线程}

% http://msdn2.microsoft.com/zh-cn/library/system.threading.aspx

\begin{frame}
\frametitle{多线程~(\textit{Multithreading})}
\begin{block}{\textit{Thread}}
  \CJKindent 线程本质上是一个独立运行的代码段，是操作系统分配处理器时间的基本单元，.NET 中的线程实际
  是操作系统线程的包装器，由操作系统创建和运行。
\end{block}
\begin{itemize}
\item 提高性能，可以将任务分解在多个线程中
\item 提高响应能力，如在通过网络发送文件时，接受键盘输入
\item 方便移植到多处理器的计算机上
\end{itemize}
\medskip
\begin{itemize}
\item 程序稍复杂，需要启动、监视、等待线程结束等
\item 多线程使用同一资源，需要进行同步，可能发生死锁
\item 多线程的控制需要一定的处理器时间
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{线程的状态}
% lib-thstate.jpg
\end{frame}


\begin{frame}
\frametitle{System.Threading 命名空间}
\begin{itemize}
\setlength{\itemsep}{6pt plus 1pt}
\item .NET 的线程类在 System.Threading 命名空间
\item Thread 类用于创建线程，设置优先级，挂起、激活或终止线程等
\item ThreadPool 类提供线程池，可用于发送工作项、处理异步 I/O等
\item Monitor 提供同步对对象的访问的机制
\item Mutex 一个同步基元，也可用于进程间同步
\item Semaphore 限制可同时访问某一资源或资源池的线程数
\item Timer 提供以指定的时间间隔执行方法的机制
\end{itemize}
\end{frame}



\begin{frame}[fragile]
\frametitle{Thread 类}
Thread 类的构造函数：
\begin{lstlisting}
public sealed class Thread
{
  public Thread(ThreadStart start);
  public Thread(ParameterizedThreadStart start);

  public Thread(ThreadStart start, int n);
  public Thread(ParameterizedThreadStart start, int n);
  // other members
}
public delegate void ThreadStart();
public delegate void ParameterizedThreadStart(object obj);
\end{lstlisting}

\begin{itemize}
\item ThreadStart --- 表示此线程开始执行时要调用的方法
\item ParameterizedThreadStart --- 同上，但可有一个参数
\item int n --- 限制线程堆栈大小的整数
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{线程的启动}
\begin{lstlisting}
public sealed class Thread
{
  public void Start();
  public void Start(object obj);

  // other memebers
}
\end{lstlisting}
\begin{itemize}
\item 线程创建后，需要通过 ~Start 方法开始线程的运行
\item 参数 ~obj 传给带参数的委托
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{创建并运行线程示例}
\begin{lstlisting}[escapeinside='']
using System;  using System.Threading;
public class ThreadExample {
  public static void ThreadProc() {
    for (int i = 0; i < 10; i++) {
      Console.WriteLine("ThreadProc: {0}", i);
      Thread.Sleep(0); }
  }
  public static void Main() {

    Thread t = new Thread(new ThreadStart(ThreadProc));
    t.Start(); // '线程开始运行'

    for (int i = 0; i < 4; i++) {
      Console.WriteLine("Main thread: Do some work.");
      Thread.Sleep(0);
    }
    t.Join();
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{给线程传递参数}
C\# 2.0 中，可以通过~ ParameterizedThreadStart 委托给线程传递一个对象参数
\begin{lstlisting}
  public static void ThreadProc(object o) {
    for (int i = 0; i < (int)o; i++) {
      Console.WriteLine("ThreadProc: {0}", i);
      Thread.Sleep(0); }
  }
...
    Thread t = new Thread(ThreadProc);
    // new ParameterizedThreadStart(ThreadProc)

    t.Start(20);
...
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Thread 类的成员特性}
\begin{lstlisting}
public sealed class Thread {
  public static Thread CurrentThread
  public int ManagedThreadId
  public string Name

  public ThreadPriority Priority
  public ThreadState ThreadState

  public bool IsAlive
  public bool IsBackground
  public bool IsThreadPoolThread
}
\end{lstlisting}
\begin{itemize}
\item CurrentThread --- 静态成员，获取当前正在运行的线程
\item Name --- 获取或设置线程的名称，只写一次
\item Priority --- 获取或设置一个值，该值指示线程的调度优先级
\item ThreadState --- 获取一个值，该值包含当前线程的状态
\end{itemize}
\end{frame}

% \begin{frame}
% \frametitle{Thread 类的成员方法}
% \begin{itemize}
% \item void Abort() --- 引发 ThreadAbortException，以开始终止此线程的过程
% \item void Interrupt() --- 中断处于 WaitSleepJoin 线程状态的线程
% \item void Join() --- 阻塞调用线程，直到某个线程终止为止
% \item bool Join(int/TimeSpan) --- 阻塞调用线程，直到某个线程终止或经过了指定时间为止
% \item static void Sleep(int/TimeSpan) --- 将当前线程挂起指定的时间
% \end{itemize}
% \end{frame}

\begin{frame}[fragile]
\frametitle{创建多个线程}
创建多个 ~Thread 实例即可：
\begin{lstlisting}[escapeinside='']
...
  public static void Main() {
    Thread t1 = new Thread(new ThreadStart(ThreadProc));
    Thread t2 = new Thread(ThreadProc)); //'自动转换'
    Thread t3 = new Thread(ThreadProc));

    t1.Start();
    t2.Start();
    t3.Start();

    for (int i = 0; i < 4; i++) {
      Console.WriteLine("Main thread: Do some work.");
      Thread.Sleep(0);
    }
  }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{判断线程的结束}
通过读取 ~IsAlive 特性的值：
\lstset{emph={IsAlive}}
\begin{lstlisting}
  Thread t1, t2, t3; // new Thread(...)
  ...
  t1.Start(); t2.Start(); t3.Start();

  do {
    Console.WriteLine("Waiting thread");
    Thread.Sleep(100);
  } while (t1.IsAlive && t2.IsAlive && t3.IsAlive);

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{等待线程结束}
Thread 中定义的 ~Join 方法：
\begin{lstlisting}[escapeinside='']
public sealed class Thread {
  public void Join ();
  public bool Join (int millisecondsTimeout);
  public bool Join (TimeSpan timeout);
  // '如果等待时间结束，则返回，值为 false'
}
\end{lstlisting}
使用 ~Join 等待线程结束，将进入 ~WaitSleepJoin 状态：
\lstset{emph={Join}}
\begin{lstlisting}
  Thread t1, t2, t3; // new Thread(...)
  ...
  t1.Start(); t2.Start(); t3.Start();

  t1.Join();  Console.WriteLine("Child #1 joined.");

  t2.Join();  Console.WriteLine("Child #2 joined.");

  t3.Join();  Console.WriteLine("Child #3 joined.");

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{挂起线程}
Thread 定义用于挂起~ (\textit{suspend}) 和恢复~ (\textit{resume}) 线程的两个方法: 
\begin{lstlisting}
public sealed class Thread{
  public void Resume();
  public void Suspend();
}
\end{lstlisting}
\begin{itemize}
\item 任何线程都可以挂起其他线程
\item 被挂起的线程只能被其他线程恢复
\item C\# 2.0 推荐使用其他方式暂停线程执行
\end{itemize}

\end{frame}


\begin{frame}[fragile]
\frametitle{使线程睡眠}
\begin{itemize}
\item Sleep 静态方法使线程睡眠，进入 ~WaitSleepJoin 状态
\end{itemize}
\begin{lstlisting}
public sealed class Thread {
  public static void Sleep (int millisecondsTimeout);
  public static void Sleep (TimeSpan timeout);

  public static void SpinWait(int iterations);
}
\end{lstlisting}
\begin{itemize}
\item int 值表示毫秒数
\item TimeSpan 可以更方便的表示时间
\begin{itemize}
\item TimeSpan.Infinite --- 无限
\item TimeSpan.FromDays(2) --- 2 天
\end{itemize}
\item SpinWait 导致线程等待由 iterations 参数定义的时间量
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{中止线程执行}
Thread 类中的中止方法：
\begin{lstlisting}
public sealed class Thread {
  public void Abort();
  public void Abort(object stateInfo);
  public staic void ResetAbort();
}
\end{lstlisting}
\begin{itemize}
\item 被中止的线程会发生 ~ThreadAbortException 异常
\item 线程中的即使 ~catch 该异常，也会被中止，除非调用 ~Thread.ResetAbort()
\item 该异常的 ~ExceptionState 即 ~stateInfo 参数
\item WaitSleepJoin 状态的线程可以被中止，但 ~Suspended 的不可以
\end{itemize}
\end{frame}

\begin{frame}[fragile,plain]
\frametitle{线程中止的示例}
\begin{lstlisting}
...
  public static void DoWork()
  { try
    { int i = 0;
      while (true) Console.WriteLine (i++);
    }
    catch (ThreadAbortException e)
    { string c ;
      c = (string) e.ExceptionState;
      Console.WriteLine (c);
    }
  }
  static void Main()
  {
    Thread w = new Thread (DoWork);
    w.Start();
    Thread.Sleep (200);
    w.Abort ("Time to go");
    w.Join();
  }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{线程的优先级}
Thread 类中的优先级特性：
\begin{lstlisting}
public sealed class Thread {
  public ThreadPriority Priority {get; set};
}
public enum ThreadPriority {
  Lowest, BelowNormal, Normal, AboveNormal, Highest
}
\end{lstlisting}

\begin{itemize}
\item 高优先级得到更多的 ~CPU 时间，但具体调度算法随操作系统而不同
\end{itemize}

\begin{lstlisting}
  Thread t1, t2; // new Thread(...)
  ...
  t1.Priority = ThreadPriority.AboveNormal;
  t2.Priority = ThreadPriority.Normal;
  ...
  t1.Start(); t2.Start();
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{线程同步}
% lock, Wait(), Pulse(), PulseAll()
\begin{itemize}
\item 当同一资源只能被一个线程使用时，需要使用同步技术
\item 使用 ~\texttt{lock} 进行同步非常容易
\item 也可以使用功能更全的 ~Monitor 类来实现
\end{itemize}
\lstset{emph={lock}}
\begin{lstlisting}
class SumArray {
  int sum;
  public int sumIt(int[] nums) {
    lock(this) { // lock the entire method
      sum = 0;
      for(int i=0; i < nums.Length; i++) {
        sum += nums[i];
        Console.WriteLine("Running total for " +
               Thread.CurrentThread.Name + " is " + sum);
        Thread.Sleep(10);
      }
      return sum;
    }
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Monitor 类}
\begin{itemize}
\item Monitor 中用于控制进入临界区的静态方法：
  \begin{itemize}
  \item static void Enter(object s) --- 如果获得对象 ~s，进入临界区，否则阻塞
  \item static void Exit(object s) --- 释放对象 ~s，退出临界区
  \end{itemize}
\item   实际上~C\# 中的 ~lock 语句就是通过这两个方法实现的\medskip \pause

\item   此外 ~Monitor 还提供了一个不会被阻塞的方法：
  \begin{itemize}
  \item static bool TryEnter(object s)

    TryEnter 如果获得 ~s，返回 ~\texttt{true}，并进入临界区；否则直接返回 ~\texttt{false}。因此
    可以通过判断其返回值，在未获得 ~s 时进行一些必要的操作。

  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{进程之间的交互运行}
\begin{itemize}
\setlength{\itemsep}{6pt plus 1pt}
\item 线程的 ~WaitSleepJoin 状态用来互相等待
  \begin{itemize}
  \item static bool Wait(object s) --- 释放 ~s，并等待其他线程通知\\
    \smallskip \CJKindent 当线程调用 Wait 时，它释放对象的锁并进入对象的等待队列，直到它们接收到由锁
    的所有者发送的 ~Pulse 或~PulseAll 的信号为止。\smallskip
  \item static void Pulse(object s) / static void PulseAll(object s) \\
    \smallskip \CJKindent 通知其他等待线程，资源 ~s 状态即将改变。如果发送了 ~Pulse，则只影响位于等待
    队列最前面的线程。如果发送了 ~PulseAll，则将影响正等待该对象的所有线程。
  \end{itemize}
\pause
\item 只有锁的当前所有者可以使用 ~Pulse 向等待对象发出信号
\item 如果锁的持有者不调用 ~Pulse，Wait 将无限期地阻止
\item 如果没有调用 ~Wait 的等待线程，Pulse 的信号将被忽略
\end{itemize}
\end{frame}

\begin{frame}[fragile,plain]
\frametitle{交互示例}
\lstset{emph={Wait,Pulse,lock}}
\begin{lstlisting}[escapeinside='']
class MonitorSample {
  public Queue q = new Queue(); 
  public void run1() { // for thread 1
    int counter = 0;
    lock(q) {
      while(counter < 1000) {
        Monitor.Wait(q);    // '释放并等待'
        q.Enqueue(counter++);
        Monitor.Pulse(q); } // '通知'
    }
  }
  public void run2() { // for thread 2
    lock(q) {
      Monitor.Pulse(q);
      while(Monitor.Wait(q,1000)) {
        int counter = (int)q.Dequeue();
        Monitor.Pulse(q); } //end of while
    }
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Mutex 类}
% http://msdn2.microsoft.com/zh-cn/library/system.threading.mutex.aspx
\end{frame}

\begin{frame}
\frametitle{Semaphore 类}
% http://msdn2.microsoft.com/zh-cn/library/system.threading.semaphore.aspx
\end{frame}


\begin{frame}
\frametitle{线程终止}

\end{frame}


\begin{frame}
\frametitle{Interlocked 类}

\end{frame}

\begin{frame}
\frametitle{ThreadPool 类}
% http://msdn2.microsoft.com/zh-cn/library/0ka9477y.aspx
\end{frame}

\begin{frame}
\frametitle{Timer 类}

\end{frame}

\begin{frame}
\frametitle{线程相关的异常}

\end{frame}


% Local Variables:
% mode: LaTeX
% TeX-master: "part-04.tex"
% TeX-header-end: "% End-of-Header$"
% TeX-trailer-start: "% Start-of-Trailer$"
% fill-column: 100
% coding: gb2312-dos
% End:

