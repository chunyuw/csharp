%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn>

\part{类}

\section{类的基本组成}

\begin{frame}[fragile]
\frametitle{类的定义}
类定义的一般格式：
\begin{lstlisting}
[attribute]
[modifiers] class identifier [:baselist]
{
  // class body
}[;]
\end{lstlisting}
\begin{itemize}
\item attribute --- 类的属性
\item modifiers --- 类的修饰符
\item baselist  --- 基类和实现的接口
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{一个简单的例子}
\lstset{emph={new}}
\begin{lstlisting}
class Circle {
  public int R;
  public static double pi = 3.14159;
  public double Perimeter(){
    return 2 * pi * R;
  }
}
class test {
  static void Main(){
    Circle c = new Circle();
    c.R = 20;
    System.Console.WriteLine(c.Perimeter());
  }
}
\end{lstlisting}
\end{frame}

\note{
  \begin{itemize}
  \item 这里是一个类的例子，也是一个应用程序的例子
  \item class 来定义类，new 关键字创建实例
  \item C\#中，没有全局的函数和变量，都必须放在类中，即使是 Main()函数
  \item Main() 函数必须是 static 的，而且首字母大写
  \end{itemize}}


\begin{frame}[fragile]
\frametitle{类的属性}
\CJKindent 属性(\textit{attribute})是可选的，可以有一个或多个，用逗号分割并放
在中括号中。

\begin{lstlisting}
[ClassDesc(Author="Jack")]
public class XXX { ... }

[Obsolete("This class should no longer be used")]
public class YYY { ... }

\end{lstlisting}

\begin{itemize}
\item 属性也可以对类的成员起作用
\item 遵行 ~CLR 的编译器会将属性信息写入元数据中
\item .NET 框架中定义了几百个预定义的属性，功能繁多
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{访问修饰符}

\CJKindent C\# 中通过类或类成员的访问限制，能够完全控制谁能使用类或类的成员。

\begin{tabular}[tb]{l|l}
\hline 修饰符 & 访问权限\\
\hline
    private       & 仅用于嵌套类，其容器类可访问\\
    protected     & 仅用于嵌套类，其容器类和派生类可访问\\
    internal      & 当前程序集内可访问\\
    protected internal & 当前程序集或派生类可访问\\
    public        & 任何程序集中都可以访问\\ \hline
  \end{tabular}
\begin{itemize}
\item 如果省略，默认的访问权限为 ~internal
\item 派生类和基类要有相同的访问权限
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{类的继承}

\begin{onlyenv}<1> 
  \begin{block}{继承}
    \CJKindent 一个类（派生类）怎样从另一个类（基类）中共享特性和行为的方法。
  \end{block}
\begin{lstlisting}[escapeinside=<>]
class Circle { 
  public int R; 
  public static double pi = 3.1415;
  public double Area(){
    return pi * R * R;
  }
}
class Ring : Circle {
  public int r; // <内半径>
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<2>
  \begin{itemize}
  \item 建立类的层次结构，公用的功能放在基类
  \item 代码重用，基类的字段和代码
  \item C\#~只允许单继承，但可实现多个接口(\textit{interface})\par
\lstinline|public class MyClass:Interface1, Interface2 {...}|
  \item 通过~\textit{sealed}~修饰的密封类，不能被继承\par
\lstinline|public sealed class secret {...}|
  \end{itemize}
\end{onlyenv}
\end{frame}

\begin{frame}
\frametitle{类的成员}
\begin{onlyenv}<1>
  \begin{block}{字段 (\textit{fields})}
    描述对象属性的简单数据类型、自定义的结构或其他类。
  \end{block}
  \begin{block}{方法 (\textit{methods})}
    对象中执行计算或其他操作的函数成员。
  \end{block}
  \begin{block}{特性 (\textit{properties})}
    对类中字段提供特定的访问方法。
  \end{block}
\end{onlyenv}
\begin{onlyenv}<2>
  \begin{block}{委托 (\textit{delegates})}
    运行时用来动态调用不同的方法的特殊成员。
  \end{block}
  \begin{block}{事件 (\textit{events})}
    建立程序之间的连接方法和运行过程的终结操作。
  \end{block}
  \begin{block}{索引器 (\textit{indexers})}
    通过方括号的语法访问成员的方法。
  \end{block}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile]
\frametitle{静态成员和实例成员}
\begin{onlyenv}<1>
  \begin{itemize}
  \item 静态成员使用关键字~static~修饰，否则为实例成员
    \lstset{emph={static}}
\begin{lstlisting}[escapeinside=<>]
class Circle {
  // <实例变量>
  public int R; 
  // <静态变量>
  public static double pi = 3.14159; 
  // <实例方法>
  public double Perimeter(){
    return 2 * pi * R;
  }
}
\end{lstlisting}
  \end{itemize}
\end{onlyenv}
\begin{onlyenv}<2>
  \begin{itemize}
  \item 静态成员通过类名访问，实例成员通过对象名访问
\begin{lstlisting}[escapeinside=<>]
Circle c  = new Circle(); // <创建一个实例>
Circle.pi = 3.14159265;   // <访问静态变量>
      c.R = 100;          // <访问实例变量>

\end{lstlisting}
  \item 静态成员和具体实例无关，是类本身的特征
  \item 通过静态变量，可以在类的实例之间共享信息
  \item 静态成员在加载类的时候初始化，分配内存空间
  \end{itemize}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile]
\frametitle{常量和只读变量}
\begin{itemize}
\item 分别使用~const~和~readonly~修饰
\item 常量在编译时初始化，只读变量在运行时初始化
\item 初始化之后，都不可以被修改
\item 引用类型只能使用只读变量，因为无法在编译时初始化
\end{itemize}
\lstset{emph={readonly,const}}
\begin{lstlisting}
  const    string url1="www.hit.edu.cn";
  readonly string url2="www.cs.hit.edu.cn";
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{方法(methods)}
\begin{itemize}
\item 方法是一个命名的代码块，用于计算或其他操作的函数成员，表示类的行为
\item 分为实例方法和静态方法，静态方法通过类名访问
\item 方法可以被声明为 virtual、abstract 或 sealed
\begin{itemize}
\item virtual --- 可以被派生类覆盖
\item abstract --- 没有具体实现，需要派生类实现
\item sealed --- 不可以被覆盖
\end{itemize}
\item 方法可以被继承、覆盖和隐藏
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{构造函数(constructors)}
构造函数是一个（或多个）特殊的方法，用于初始化对象。可以分为静态构造函数
和实例构造函数两种。
\pause
\begin{itemize}
\item 构造函数名字与类名相同，但无返回类型
\begin{lstlisting}[escapeinside=<>]
class Circle { public int R;
  // <初始化为单位圆，实例构造函数>
  public Circle() { R=1;}    }
\end{lstlisting}
  \pause
\item 静态构造函数(用static修饰)，在加载类时调用，用于初始化静态变量
\end{itemize}
\end{frame}
\note{
  \begin{itemize}
  \item 构造函数的定义不是必须的
  \end{itemize}
}

\begin{frame}[fragile]
\frametitle{析构函数(destructors)}
析构函数是当对象被清除时被调用的特殊方法。
\begin{itemize}
\item 名字：以字符“\verb|~|”开始的类名，无返回类型
\begin{lstlisting}[escapeinside=<>]
class Circle {
  public int R;
  public Circle() { R=1;}
  ~Circle() { /* <析构函数体> */  } 
}
\end{lstlisting}
  \pause
\item 由于 ~C\# 的自动垃圾回收，一般不需要自己创建析构函数
  \pause
\item 构造函数和析构函数的定义都不是必须的
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{重载(overload)}
\begin{block}{方法的重载}
  \CJKindent 重载，对不同对象，使用相同的方法，进行不同的操作。在同一个类中，定
  义同一名称的多个成员，被重载的成员方法之间的唯一差别就是具有不同的参数类型和
  个数。\pause
  \begin{itemize}
  \item 索引器、构造函数、操作符都可以重载
  \item 调用时，C\#会根据参数列表的不同自动选择
  \end{itemize}
\end{block}
\pause
\begin{lstlisting}[escapeinside=<>]
class Circle{   public int R;
  public Circle()      { R = 1;}
  public Circle(int x) { R = x;}
}  ...
  Circle a = new Circle();
  Circle b = new Circle(20);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{特性(properties)}
\begin{onlyenv}<1>
  \begin{block}{特性}
    对字段提供特定的访问方式，为类提供封装。
  \end{block}
  \begin{itemize}
  \item 特性的访问是透明的，类似成员变量
  \item get~提供读访问，set~提供写访问
  \item 通过特性可进行完整性检查，类似成员方法
  \end{itemize}
\end{onlyenv}
\begin{onlyenv}<2>
  \lstset{emph={get,set}}
\begin{lstlisting}[escapeinside=<>]
class Circle {
  protected int R;
  public  int Radius {
    get { return R; }
    set { if(value>0) R=value; }  
  }
}
...
  Circle c = new Circle();
  c.Radius = 20;
  Console.WriteLine(c.Radius);

\end{lstlisting}
\end{onlyenv}
\end{frame}

\begin{frame}
\frametitle{嵌套类}

\end{frame}

\section{类型转换}

\setbeamerfont{table}{size=\small}
\begin{frame}
\frametitle{所有类的基类 ~System.Object}
\begin{itemize}
\item C\#中的所有类型直接或间接的基类，也是 .NET Framework 中所有类的最终基类
\item 自定义的类，都对 ~Object 隐式继承，不需要在类的定义中声明
\end{itemize}
\pause
\begin{block}{为派生类提供的底层服务}
  \usebeamerfont{table}
  \begin{tabular}{l|l}
    Equals()      & 确定两个对象实例是否相等\\
    GetHashCode() & 生成对象相对应的数字以支持哈希表\\
    ToString()    & 生成描述类的实例的可读文本字符串\\
    GetType()     & 获取当前实例的类型\\
    Finalize()    & 在自动回收对象之前执行清理操作\\
  \end{tabular}
  \normalfont
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{值类型与引用类型}
\begin{itemize}
\item 值类型，赋值或传递给一个方法时，生成一个新的实例
\item 引用类型，赋值或传递给一个方法时，使用当前实例（只传地址）
\end{itemize}
\begin{lstlisting}[escapeinside=<>]
class Circle { public int R; }
...
  Circle c = new Circle();
  c.R = 10;
  Circle d = c;
  d.R = 20;
  Console.WriteLine(c.R); // <输出为> 20
\end{lstlisting}
\end{frame}

% \begin{frame}
% \frametitle{类型的层次结构}
% \color[rgb]{1,0,0} 31页层次结构图
% \end{frame}

\begin{frame}[fragile]
\frametitle{类型之间的转换}
\begin{block}{隐式转换}
  \begin{itemize}
  \item 当信息不会丢失时 \\如 int$\rightarrow$long 的转换，int$\rightarrow$float 的转换；
  \item 从派生类到基类的转换
  \end{itemize}
\end{block}
\pause
\begin{block}{显式转换}
  \begin{itemize}
  \item 当不能进行隐式转换时，必须使用显式转换
  \item 使用显式转换，也可以减少错误和异常
  \end{itemize}
\end{block}
\pause
\begin{lstlisting}[escapeinside=<>]
  int  a = 5;
  long b = a;         // <隐式转换>
  int  c = (int) b;   // <显式转换>

\end{lstlisting}
\note{转换是指把对象从一种类型改变为另外一种类型的能力。}
\end{frame}

\begin{frame}[fragile]
\frametitle{装箱(boxing)与拆箱(unboxing)}
\begin{block}{装箱}
  \begin{itemize}
  \item 将值类型转换为引用类型的过程
  \item 系统为引用类型分配新内存，创建对象，并把值类型的内容复制到新分配的内存中。
  \end{itemize}
\end{block}
\pause
\begin{block}{拆箱}
  \begin{itemize}
  \item 将引用类型的对象转换为值类型的过程
  \item 拆箱过程必须是显式的
  \end{itemize}
\end{block}
\pause
\begin{lstlisting}[escapeinside=<>]
  int    a = 5;
  object o = a;       // <隐式转换，装箱>
  int    b = (int) o; // <显式转换，拆箱>

\end{lstlisting}
\end{frame}

% Local Variables: 
% mode: LaTeX
% TeX-master: "lesson-02.tex"
% TeX-header-end: "% End-Of-Header$"
% TeX-trailer-start: "% Start-Of-Trailer$"
% coding: gb2312-dos
% End:
