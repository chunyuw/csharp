%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn> %%

\section{文件和数据流}

\begin{frame}
\frametitle{数据流}
\begin{block}{\textit{Stream}}
  \CJKindent C\# 将 ~I/O 抽象成数据流的形式，屏蔽了不同 ~I/O 设备之间的差异，提
  供一致的面向流的行为方式，并通过抽象类 ~\texttt{Stream} 体现。
\end{block}
\begin{itemize}
\item 这些类都在 ~System.IO 命名空间中
\item 流的基本操作
\begin{itemize}
\item 从流读取：从流到数据结构的数据传输
\item 向流写入：从数据源到流的数据传输
\item 支持查找：对流内的当前位置进行的查询和修改
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Stream 类}

抽象类 ~Stream 提供了对流的基本操作：
\begin{itemize}
\item void \textbf{Close}() --- 关闭数据流
\item void \textbf{Flush}() --- 将缓冲中的数据写入设备
\item int \textbf{ReadByte}() --- 读取一个用整数表示的字节
\item int \textbf{Read}(byte[] buf, int offset, int numBytes) \\
  将读入的字节写入 ~buf 缓冲中
\item long \textbf{Seek}(long offset, SeekOrigin origin)  \\
  在数据流中设置当前位置
\item void \textbf{WriteByte}(byte b) -- 向流中写入一个字节
\item void \textbf{Write}(byte[] buf, int offset, int numBytes) \\
  将 ~buf 中的数据写入流
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Stream 类的特性}
Stream 的派生类中，不一定都支持所有的操作，可如下判断：
\begin{itemize}
\item bool CanRead --- 是否可以读取
\item bool CanWrite --- 是否可以写入
\item bool CanSeek --- 是否支持定位
\item bool CanTimeout --- 是否会有超时
\item long Length --- 流的长度
\item long Position --- 目前在流中的位置，可以修改
\end{itemize}
\end{frame}


\begin{frame}<0| handout:0>
\frametitle{基本的~I/O 字节流类}
\color{red}

Stream 是抽象类，如下几个是它的直接

\begin{tabular}[htbp]{l|l}
\hline
基本 ~I/O 流类 & 功能 \\
\hline
BufferedStream & \small 用于给其他的流添加缓冲，提高性能 \\
CryptoStream & \small 在 ~System.Security.Cryptography 中，用于加密 \\
MemoryStream & \small 在内存中直接访问所封装的数据 \\
NetworkStream & \small 在 ~System.Net.Sockets 中，用于封装网络连接上的流 \\
FileStream & \small 基本的文件操作类 \\
\hline
\end{tabular}

\end{frame}

\begin{frame}
\frametitle{FileStream 类}
{\CJKindent FileStream 是对文件进行读取、写入和关闭操作，对管道、标准输入输出等设备的操作。}
\begin{figure}
  \centering
  \input{pgf/lib-filestream}
\end{figure}
\begin{itemize}
\item FileMode 指定文件的打开方式
\item FileAccess 指定文件的访问方式
\item FileShare 指定文件的共享方式
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{FileStream 示例}
\lstset{emph={WriteByte,ReadByte,Position,Length}}
\begin{lstlisting}
FileStream fs = new FileStream (@"C:\abc.txt", 
    FileMode.OpenOrCreate, FileAccess.ReadWrite);
byte[] data = new byte[5]{65,66,67,68,69}; // ABCDE

foreach (byte b in data){
  fs.WriteByte(b);}

fs.Position = 0; 

for (int i=0; i<fs.Length; i++)
  Console.Write((char) fs.ReadByte());

fs.Close();
\end{lstlisting}
\begin{itemize}
\item \texttt{fs.Position} 直接定位当前位置
\item \texttt{fs.Length} 直接取得文件长度
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{MemoryStream 类}
\CJKindent MemoryStream 主要用于临时数据存储，在内存中使用流的方式处理数据。
\begin{lstlisting}[escapeinside=<>]
// <使用> MemoryStream <缓冲一个文件>
FileStream fsIn = new FileStream(...);

MemoryStream ms = new MemoryStream();
int oneByte;

while ((oneByte = fsIn.ReadeByte()) != -1){
  ms.WriteByte ((byte)oneByte);
}
fsIn.Close();

// <流> ms <中的内容和文件一样，但效率更高>

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{BufferedStream 类}
\CJKindent BufferedStream 通过提供默认 ~4096 字节的缓冲，提高 ~I/O 的效率。这
几个 ~Stream 类都是基于字节的，即字节流 ~(\textit{Byte Stream})。
\begin{lstlisting}
Stream fs = new FileStream(@"C:\temp.txt"
    FileMode.OpenOrCreate, FileAccess.Write);

BufferedStream bs = new BufferedStream(fs);

byte[] data = new byte[5]{65,66,67,68,69}; // ABCDE

foreach (byte b in data){
  bs.WriteByte(b);}

bs.Close();
fs.Close();

\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{抽象类~ TextReader/TextWriter}
\CJKindent 用于处理文本而不是原始字节的抽象类。
\medskip
\begin{itemize}
\setlength{\itemsep}{6pt plus 1pt}
\item TextReader 类
\begin{itemize}
\setlength{\itemsep}{4pt plus 1pt}
\item Peek(), Read(), ReadBlock(), ReadLine(), ReadToEnd()
\item Dispose(), Close()
\end{itemize}
\item TextWriter 类
\begin{itemize}
\setlength{\itemsep}{4pt plus 1pt}
\item Write(), WriteLine(), Flush(), Dispose()
\item Encoding, NewLine
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{StreamReader/StreamWriter}
\CJKindent 继承自 ~TextReader/TextWriter 用于处理流上的字符的类，即字符流~
(\textit{Character Stream})。对于文件来说，处理基于 ~FileStream 的字符数据。
\medskip

多种构造函数，多种方式创建实例：
\lstset{emph={[4]path,s,append,e}}
\begin{lstlisting}
public StreamWriter(string path)
public StreamWriter(stream    s)

public StreamWriter(string path, bool append)
public StreamWriter(stream    s, bool append)

public StreamWriter(string path, bool append, Encoding e)
public StreamWriter(stream    s, bool append, Encoding e)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{字符流示例}
\lstset{emph={Read,ReadToEnd}}
\begin{lstlisting}
FileStream fs = new FileStream(...); // Open a text file
StreamReader reader = new StreamReader(fs);

char[] buff = new char[4];
int count = reader.Read(buff,0,buff.Length);

string cup = reader.ReadToEnd();

fs.Position = 0;

string line = null;
while((line = reader.ReadLine() != null){
  Console.WriteLine(line);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{编码转换的示例}
\begin{lstlisting}
using System; using System.IO; using System.Text;
public class Convert
{ static void Main()
  {
  StreamReader sr = new 
   StreamReader("G.txt",Encoding.GetEncoding("gb2312"));

  StreamWriter sw = new 
   StreamWriter("B.txt",false,Encoding.GetEncoding("big5"));

  string str = null;
  
  while((str = sr.ReadLine()) != null)
  { sw.WriteLine (str); }

  sr.Close(); sw.Close();
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{StringReader/StringWriter}
\CJKindent 通过 ~StringBuilder 存储的内存字符流，操作方式和流相同，但可以通过
~GetStringBuilder 获取 ~StringBuilder 对象。

\begin{lstlisting}
StringWriter writer = new StringWriter();

writer.WriteLine("Hello world!");
writer.WriteLine("Some Text");

StringBuilder s = writer.GetStringBuilder();

s.Append("Some Other Text");
Console.WriteLine(s.ToString());

\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
\frametitle{BinaryReader/BinaryWriter}
\CJKindent 用于处理值类型的数据的数据流，读写的数据使用计算机内部的二进制格式。

\begin{columns}[t]
  \column{.5\textwidth}
  \begin{itemize}
  \item BinaryWriter 重载各种数据的写操作\lstset{emph={[4]val}}
\begin{lstlisting}
void Write(byte   val)
void Write(sbyte  val)
void Write(int    val)
void Write(int[]  val)
void Write(double val)
void Write(char[] val)
void Write(string val)
...
\end{lstlisting}
  \end{itemize}
  \column{.5\textwidth}
  \begin{itemize}
  \item BinaryReader 提供不同读操作的方法
\begin{lstlisting}
bool   ReadBoolean()
byte   ReadByte()
sbyte  ReadSByte()
int    ReadInt32()
ulong  ReadUInt64()
double ReadDouble()
float  ReadSingle()
...
\end{lstlisting}
  \end{itemize}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Stream 之间的区别}
\begin{itemize}
\setlength{\itemsep}{6pt plus 1pt}
\item Stream 是流类型的抽象基类
\item TextReader/TextWriter 是处理字符(文本)的抽象基类
\item 基于字节的流类型：{\small FileStream, BufferedStream, MemoryStream}
\item 基于字符的流类型：{\small StreamReader/StreamWriter, StringReader/StringWriter}
\item 基于数据的流类型：{\small BinaryReader/BinaryWriter}
\end{itemize}
\begin{figure}
  \centering
  \input{pgf/lib-streamtree}
\end{figure}
\end{frame}

\begin{frame}[fragile]
\frametitle{Console I/O}
\CJKindent Console I/O 定义在 ~System 命名空间中，提供基本的控制台操作。
\begin{itemize}
\item 标准 ~I/O 流 ~Console.In, Console.Out, Console.Error
\begin{lstlisting}
Console.In.ReadLine();   // TextReader
Console.Out.WriteLine(); // TextWriter
\end{lstlisting}
\item Console 类提供静态的方法，直接访问标准 ~I/O 流\\
Read(), ReadLine(), Write(), WriteLine()

\item static ConsoleKeyInfo \textbf{ReadKey}() \\
ConsoleKeyInfo 提供基本的按键信息，如所按的键值和 ~\texttt{ALT, CTRL, SHIFT} 等
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{目录和文件}
\CJKindent System.IO 命名空间中还有用于操作文件和目录的类。
\begin{itemize}
\item DirectoryInfo 类，Directory 类
\begin{itemize}
\item Create(), Delete() --- 创建删除目录
\item GetDirectories(), GetFiles() --- 得到文件目录列表
\end{itemize}
\item FileInfo 类，File 类
\begin{itemize}
\item Open(), Create(), OpenWrite() --- 返回 ~FileStream 对象
\item OpenText(), CreateText() --- 返回 StreamWriter 对象
\end{itemize}
\item Path 类
\begin{itemize}
\item GetDirectoryName(), GetFullFileName() \dots
\end{itemize}
\end{itemize}

\end{frame}

\section{串行化和反射}

\begin{frame}
\frametitle{串行化}
\begin{block}{\textit{Serialization}}
\CJKindent 将对象或对象的集合转换为特定的格式，适于网络传递，存储在文件、数据
库内的过程，称为对象的串行化。

{\song逆串行化} ~(\textit{Deserialization}) 过程正好相反，
将所存储的内容，转换回原来的对象。
\end{block}
.NET 支持三种主要的串行化：
\begin{itemize}
\item 二进制串行化，转换为二进制流~(BinaryFormatter 类)
\item SOAP 串行化，转换为~SOAP 标准格式~(SoapFormatter 类)
\item XML 串行化，转换为~XML 格式~(XmlSerializer 类)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{串行化的过程}
\begin{itemize}
\item 串行化时，根据对象的引用关系，构建一个对象图
\item 依次将该对象包括的全部成员对象串行化，完成深拷贝
\item 串行化发生前后会引发~OnSerializing 和~OnSerialized 事件
\item 串行化是基于对象的，因此不包括静态成员
\medskip \pause
\item 串行化通过不同~Formatter 完成，有共同的接口~IFormatter
\begin{lstlisting}
public interface IFormatter {
  object Deserialize(Stream s);
  void   Serialize(Stream s, object graph);
  // other members
}
\end{lstlisting}
\item C\# 2.0 还提供了泛型接口 ~IGenericFormatter
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{二进制串行化}
\begin{itemize}
\item 使用 ~BinaryFormatter 
\item 定义在 ~System.Runtime.Serialization.Formatters.Binary
\end{itemize}
\begin{lstlisting}
  Circle c = new Circle();
  FileStream fstream = 
    new FileStream("data.out",FileMode.Create);
 
  BinaryFormatter bf = new BinaryFormatter();
  bf.Serialize(fstream,c);
  fstream.Close();
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{SOAP 串行化}
\begin{itemize}
\item 使用 ~SoapFormatter
\item 定义在 ~System.Runtime.Serialization.Formatters.Soap
\end{itemize}
\begin{lstlisting}
using System.Runtime.Serialization.Formatters.Soap;
[Serializable]
public class MyClass{
  public int a,b;
}
  MyClass obj = new MyClass();
  obj.a = 123;  obj.b = 456;
  IFormatter f = new SoapFormatter();
  Stream s =  new FileStream("data.xml",FileMode.Create);
  using (s) {
    f.Serialize(s , obj)
  }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{可串行化属性}
\begin{itemize}
\item 串行化的类必须使用~\texttt{[Serializable]} 属性
\item 不希望串行化的成员，需要用~\texttt{[NonSerialized]} 属性
\item 可串行化属性无法通过继承得到
\end{itemize}
\begin{lstlisting}
[Serializable]
public class MyClass {
  public string str;
  public int i;

  [NonSerialized]
  int m;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{不可串行化的成员}
\begin{itemize}
\item 未被串行化的成员，在逆串行化时，恢复为该类型的默认值
\item 但可以通过~IDeserializationCallback 接口进行定制
\begin{lstlisting}
public interface IDeserializationCallback {
  void OnDeserialization(object sender);
}
\end{lstlisting}
\end{itemize}
\lstset{emph={[3]IDeserializationCallback,OnDeserialization}}
\begin{lstlisting}
[Serializable]
public class MyClass:IDeserializationCallback {
  [NonSerialized]
  IDbConnection m_Connection;
  ...
  public void OnDeserialization(object sender){
    m_Connection = new SqlConnection();
    m_Connection.ConnectionString = "...";
    m_Connection.Open();
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{串行化和事件}
\begin{itemize}
\item 串行化事件：OnSerializing, OnSerialized
\item 逆串行化事件：OnDeSerializing, OnDeSerialized
\item 事件处理的方法，在被串行化的对象中实现
\item 事件的类型：
\begin{lstlisting}
void EVENTNAME(StreamingContext context);
\end{lstlisting}
\end{itemize}
\begin{lstlisting}
public class Chair {
  [OnDeserialized]
  void OnDeserialized(StreamingContext context) {
    if(Val == "abc") Val = "efg";
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{串行化多个对象}
\begin{itemize}
\item 依次放入数据流进行串行化
\end{itemize}
\begin{lstlisting}
ClassA obj1 = new ClassA();
ClassB obj2 = new ClassB();

formatter.Serialize(stream, obj1);
formatter.Serialize(stream, obj2);

\end{lstlisting}
\begin{itemize}
\item 逆串行化，依次从数据流中读出即可
\end{itemize}
\begin{lstlisting}[escapeinside=<>]
// <\dots{} \dots{}>
ClassA a = (ClassA) formatter.Deserialize(stream);
ClassB b = (ClassB) formatter.Deserialize(stream);
\end{lstlisting}
\end{frame}


\begin{frame}
\frametitle{反射~(\textit{Reflection})}
\begin{itemize}
\setlength{\itemsep}{6pt plus 1pt}
\item 查看元数据，用于辅助工具的显示功能等
\item 类型发现，用户定制脚本和代码交互
\item 后期绑定，基于类型发现的动态执行方法、设置特性等
\item 运行时动态创建类型
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{获得类型信息}
\lstset{emph={Type,GetTypes}}
\begin{lstlisting}
using System; using System.Reflection;
public static void Main()
{
   Assembly a = Assembly.Load( "Mscorlib" );
   Type[] types = a.GetTypes( );
   foreach ( Type t in types )
   {
      Console.WriteLine( "Type is {0}", t );
   }
   Console.WriteLine(
      "{0} types found", types.Length );
}
\end{lstlisting}
程序输出：\scriptsize
\begin{verbatim}
Type is System.Object
Type is System.__Canon
Type is System.ICloneable
Type is System.Collections.IEnumerable
Type is System.Collections.IList
...
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{获得成员信息}
\lstset{emph={MemberInfo,GetMembers}}
\begin{lstlisting}
public static void Main( )
{ Type theType = Type.GetType("System.Int16");
  MemberInfo[] mbrInfoArray = theType.GetMembers();

  foreach (MemberInfo m in mbrInfoArray )
  { Console.WriteLine("{0} is a {1}", m, m.MemberType); }
}
\end{lstlisting}
程序输出：\scriptsize
\begin{verbatim}
System.String ToString() is a Method
Int16 Parse(System.String) is a Method
Boolean TryParse(System.String, Int16 ByRef) is a Method
Int16 MaxValue is a Field
Int16 MinValue is a Field
...
\end{verbatim}
\end{frame}


\begin{frame}[fragile]
\frametitle{获得特定的成员信息}
\lstset{emph={FindMembers}}
\begin{lstlisting}
public static void Main( )
{ Type theType = 
          Type.GetType("System.Reflection.Assembly");
  
  MemberInfo[] mbrInfoArray =
   theType.FindMembers(MemberTypes.Method,
      BindingFlags.Public|BindingFlags.Static,
      Type.FilterName, "Get*" );

  foreach(MemberInfo m in mbrInfoArray)
    Console.WriteLine("{0} is a {1}", m, m.MemberType);
}
\end{lstlisting}
程序输出：\scriptsize
\begin{verbatim}
System.Reflection.Assembly GetAssembly(System.Type) is a Method
System.Reflection.Assembly GetExecutingAssembly() is a Method
System.Reflection.Assembly GetCallingAssembly() is a Method
System.Reflection.Assembly GetEntryAssembly() is a Method
\end{verbatim}
\end{frame}


\begin{frame}[fragile]
\frametitle{后期绑定~(\textit{Late Binding})}
\begin{itemize}
\item 通过后期绑定，可以在运行时动态调用具体方法
\end{itemize}
\lstset{emph={Invoke,GetMethod}}
\begin{lstlisting}
Type theMathType = Type.GetType( "System.Math" );
Type[] p = new Type[1];
p[0] = Type.GetType( "System.Double" );

MethodInfo CosineInfo =
   theMathType.GetMethod( "Cos", p );

Object[] parameters = new Object[1];
parameters[0] = 45 * ( Math.PI / 180 );

Object returnVal =
   CosineInfo.Invoke( theMathType, parameters );

Console.WriteLine(
   "The cosine of a 45 degree angle {0}",
   returnVal );
\end{lstlisting}
\end{frame}

% Local Variables:
% mode: LaTeX
% TeX-master: "part-04.tex"
% TeX-header-end: "% End-of-Header$"
% TeX-trailer-start: "% Start-of-Trailer$"
% coding: gb2312-dos
% End:
