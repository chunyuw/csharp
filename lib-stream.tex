%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn>
%% $Rev$

\section{文件和数据流}

\begin{frame}
\frametitle{数据流}
\begin{block}{\textit{Stream}}
  \CJKindent C\# 将 ~I/O 抽象成数据流的形式，屏蔽了不同 ~I/O 设备之间的差异，提
  供一致的面向流的行为方式，并通过抽象类 ~\texttt{Stream} 体现。
\end{block}
\begin{itemize}
\item 这些类都在 ~System.IO 命名空间中
\item 流的基本操作
\begin{itemize}
\item 从流读取：从流到数据结构的数据传输
\item 向流写入：从数据源到流的数据传输
\item 支持查找：对流内的当前位置进行的查询和修改
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Stream 类}

抽象类 ~Stream 提供了对流的基本操作：
\begin{itemize}
\item void \textbf{Close}() --- 关闭数据流
\item void \textbf{Flush}() --- 将缓冲中的数据写入设备
\item int \textbf{ReadByte}() --- 读取一个用整数表示的字节
\item int \textbf{Read}(byte[] buf, int offset, int numBytes) \\
  将读入的字节写入 ~buf 缓冲中
\item long \textbf{Seek}(long offset, SeekOrigin origin)  \\
  在数据流中设置当前位置
\item void \textbf{WriteByte}(byte b) -- 向流中写入一个字节
\item void \textbf{Write}(byte[] buf, int offset, int numBytes) \\
  将 ~buf 中的数据写入流
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Stream 类的特性}
Stream 的派生类中，不一定都支持所有的操作，可如下判断：
\begin{itemize}
\item bool CanRead --- 是否可以读取
\item bool CanWrite --- 是否可以写入
\item bool CanSeak --- 是否支持定位
\item bool CanTimeout --- 是否会有超时
\item long Length --- 流的长度
\item long Position --- 目前在流中的位置，可以修改
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{基本的~I/O 字节流类}
\color{red}

Stream 是抽象类，如下几个是它的直接

\begin{tabular}[htbp]{l|l}
\hline
基本 ~I/O 流类 & 功能 \\
\hline
BufferedStream & \small 用于给其他的流添加缓冲，提高性能 \\
CryptoStream & \small 在 ~System.Security.Cryptography 中，用于加密 \\
MemoryStream & \small 在内存中直接访问所封装的数据 \\
NetworkStream & \small 在 ~System.Net.Sockets 中，用于封装网络连接上的流 \\
FileStream & \small 基本的文件操作类 \\
\hline
\end{tabular}

\end{frame}

\begin{frame}
\frametitle{FileStream 类}
{\CJKindent FileStream 是对文件进行读取、写入和关闭操作，对管道、标准输入输出等设备的操作。}
\begin{figure}
  \centering
  \input{pgf/lib-filestream}
\end{figure}
\begin{itemize}
\item FileMode 指定文件的打开方式
\item FileAccess 指定文件的访问方式
\item FileShare 指定文件的共享方式
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{FileStream 示例}
\lstset{emph={WriteByte,ReadByte,Position,Length}}
\begin{lstlisting}
FileStream fs = new FileStream (@"C:\abc.txt", 
    FileMode.OpenOrCreate, FileAccess.ReadWrite);
byte[] data = new byte[5]{65,66,67,68,69}; // ABCDE

foreach (byte b in data){
  fs.WriteByte(b);}

fs.Position = 0; 

for (int i=0; i<fs.Length; i++)
  Console.Write((char) fs.ReadByte());

fs.Close();
\end{lstlisting}
\begin{itemize}
\item \texttt{fs.Position} 直接定位当前位置
\item \texttt{fs.Length} 直接取得文件长度
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{MemoryStream 类}
\CJKindent MemoryStream 主要用于临时数据存储，在内存中使用流的方式处理数据。
\begin{lstlisting}[escapeinside=<>]
// <使用> MemoryStream <缓冲一个文件>
FileStream fsIn = new FileStream(...);

MemoryStream ms = new MemoryStream();
int oneByte;

while ((oneByte = fsIn.ReadeByte()) != -1){
  ms.WriteByte ((byte)oneByte);
}
fsIn.Close();

// <流> ms <中的内容和文件一样，但效率更高>

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{BufferedStream 类}
\CJKindent BufferedStream 通过提供默认 ~4096 字节的缓冲，提高 ~I/O 的效率。这
几个 ~Stream 类都是基于字节的，即字节流 ~(\textit{Byte Stream})。
\begin{lstlisting}
Stream fs = new FileStream(@"C:\temp.txt"
    FileMode.OpenOrCreate, FileAccess.Write);

BufferedStream bs = new BufferedStream(fs);

byte[] data = new byte[5]{65,66,67,68,69}; // ABCDE

foreach (byte b in data){
  bs.WriteByte(b);}

bs.Close();
fs.Close();

\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{抽象类~ TextReader/TextWriter}
\CJKindent 用于处理文本而不是原始字节的抽象类。
\medskip
\begin{itemize}
\setlength{\itemsep}{6pt plus 1pt}
\item TextReader 类
\begin{itemize}
\setlength{\itemsep}{4pt plus 1pt}
\item Peek(), Read(), ReadBlock(), ReadLine(), ReadToEnd()
\item Dispose(), Close()
\end{itemize}
\item TextWriter 类
\begin{itemize}
\setlength{\itemsep}{4pt plus 1pt}
\item Write(), WriteLine(), Flush(), Dispose()
\item Encoding, NewLine
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{StreamReader/StreamWriter}
\CJKindent 继承自 ~TextReader/TextWriter 用于处理流上的字符的类，即字符流~
(\textit{Character Stream})。对于文件来说，处理基于 ~FileStream 的字符数据。
\medskip

多种构造函数，多种方式创建实例：
\lstset{emph={[4]path,s,append,e}}
\begin{lstlisting}
public StreamWriter(string path)
public StreamWriter(stream    s)

public StreamWriter(string path, bool append)
public StreamWriter(stream    s, bool append)

public StreamWriter(string path, bool append, Encoding e)
public StreamWriter(stream    s, bool append, Encoding e)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{字符流示例}
\begin{lstlisting}
FileStream fs = new FileStream(...); // Open a text file
StreamReader reader = new StreamReader(fs);

char[] buff = new char[4];
int count = reader.Read(buff,0,buff.Length);

string cup = reader.ReadToEnd();

fs.Position = 0;

string line = null;
while((line = reader.ReadLine() != null){
  Console.WriteLine(line);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{编码转换的示例}
\begin{lstlisting}
using System; using System.IO; using System.Text;
public class Convert
{ static void Main()
  {
  StreamReader sr = new 
   StreamReader("G.txt",Encoding.GetEncoding("gb2312"));

  StreamWriter sw = new 
   StreamWriter("B.txt",false,Encoding.GetEncoding("big5"));

  string str = null;
  
  while((str = sr.ReadLine()) != null)
  { sw.WriteLine (str); }

  sr.Close(); sw.Close();
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{StringReader/StringWriter}
\CJKindent 通过 ~StringBuilder 存储的内存字符流，操作方式和流相同，但可以通过
~GetStringBuilder 获取 ~StringBuilder 对象。

\begin{lstlisting}
StringWriter writer = new StringWriter();

writer.WriteLine("Hello world!");
writer.WriteLine("Some Text");

StringBuilder s = writer.GetStringBuilder();

s.Append("Some Other Text");
Console.WriteLine(s.ToString());

\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
\frametitle{BinaryReader/BinaryWriter}
\CJKindent 用于处理值类型的数据的数据流，读写的数据使用计算机内部的二进制格式。

\begin{columns}[t]
  \column{.5\textwidth}
  \begin{itemize}
  \item BinaryWriter 重载各种数据的写操作\lstset{emph={[4]val}}
\begin{lstlisting}
void Write(byte   val)
void Write(sbyte  val)
void Write(int    val)
void Write(int[]  val)
void Write(double val)
void Write(char[] val)
void Write(string val)
...
\end{lstlisting}
  \end{itemize}
  \column{.5\textwidth}
  \begin{itemize}
  \item BinaryReader 提供不同读操作的方法
\begin{lstlisting}
bool   ReadBoolean()
byte   ReadByte()
sbyte  ReadSByte()
int    ReadInt32()
ulong  ReadUInt64()
double ReadDouble()
float  ReadSingle()
...
\end{lstlisting}
  \end{itemize}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Stream 之间的区别}
\begin{itemize}
\setlength{\itemsep}{6pt plus 1pt}
\item Stream 是流类型的抽象基类
\item TextReader/TextWriter 是处理字符(文本)的抽象基类
\item 基于字节的流类型：{\small FileStream, BufferedStream, MemoryStream}
\item 基于字符的流类型：{\small StreamReader/StreamWriter, StringReader/StringWriter}
\item 基于数据的流类型：{\small BinaryReader/BinaryWriter}
\end{itemize}
\begin{figure}
  \centering
  \input{pgf/lib-streamtree}
\end{figure}
\end{frame}

\begin{frame}[fragile]
\frametitle{Console I/O}
\CJKindent Console I/O 定义在 ~System 命名空间中，提供基本的控制台操作。
\begin{itemize}
\item 标准 ~I/O 流 ~Console.In, Console.Out, Console.Error
\begin{lstlisting}
Console.In.ReadLine();   // TextReader
Console.Out.WriteLine(); // TextWriter
\end{lstlisting}
\item Console 类提供静态的方法，直接访问标准 ~I/O 流\\
Read(), ReadLine(), Write(), WriteLine()

\item static ConsoleKeyInfo \textbf{ReadKey}() \\
ConsoleKeyInfo 提供基本的按键信息，如所按的键值和 ~\texttt{ALT, CTRL, SHIFT} 等
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{目录和文件}
\CJKindent System.IO 命名空间中还有用于操作文件和目录的类。
\begin{itemize}
\item DirectoryInfo 类，Directory 类
\begin{itemize}
\item Create(), Delete() --- 创建删除目录
\item GetDirectories(), GetFiles() --- 得到文件目录列表
\end{itemize}
\item FileInfo 类，File 类
\begin{itemize}
\item Open(), Create(), OpenWrite() --- 返回 ~FileStream 对象
\item OpenText(), CreateText() --- 返回 StreamWriter 对象
\end{itemize}
\item Path 类
\begin{itemize}
\item GetDirectoryName(), GetFullFileName() \dots
\end{itemize}
\end{itemize}

\end{frame}

\section{串行化}

\begin{frame}
\frametitle{串行化}

\end{frame}



% Local Variables:
% mode: LaTeX
% TeX-master: "part-04.tex"
% TeX-header-end: "% End-of-Header$"
% TeX-trailer-start: "% Start-of-Trailer$"
% coding: gb2312-dos
% End:
