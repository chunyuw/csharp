%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn>
%% $Rev$

\section{文件和数据流}

\begin{frame}
\frametitle{数据流}
\begin{block}{\textit{Stream}}
  \CJKindent C\# 将 ~I/O 抽象成数据流的形式，屏蔽了不同 ~I/O 设备之间的差异，提
  供一致的面向流的行为方式，并通过抽象类 ~\texttt{Stream} 体现。
\end{block}
\begin{itemize}
\item 这些类都在 ~System.IO 命名空间中
\item 流的基本操作
\begin{itemize}
\item 从流读取：从流到数据结构的数据传输
\item 向流写入：从数据源到流的数据传输
\item 支持查找：对流内的当前位置进行的查询和修改
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Stream 类}

抽象类 ~Stream 提供了对流的基本操作：
\begin{itemize}
\item void \textbf{Close}() --- 关闭数据流
\item void \textbf{Flush}() --- 将缓冲中的数据写入设备
\item int \textbf{ReadByte}() --- 读取一个用整数表示的字节
\item int \textbf{Read}(byte[] buf, int offset, int numBytes) \\
  将读入的字节写入 ~buf 缓冲中
\item long \textbf{Seek}(long offset, SeekOrigin origin)  \\
  在数据流中设置当前位置
\item void \textbf{WriteByte}(byte b) -- 向流中写入一个字节
\item void \textbf{Write}(byte[] buf, int offset, int numBytes) \\
  将 ~buf 中的数据写入流
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Stream 类的特性}
Stream 的派生类中，不一定都支持所有的操作，可如下判断：
\begin{itemize}
\item bool CanRead --- 是否可以读取
\item bool CanWrite --- 是否可以写入
\item bool CanSeak --- 是否支持定位
\item bool CanTimeout --- 是否会有超时
\item long Length --- 流的长度
\item long Position --- 目前在流中的位置，可以修改
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{基本的~I/O 字节流类}
\color{red}

Stream 是抽象类，如下几个是它的直接

\begin{tabular}[htbp]{l|l}
\hline
基本 ~I/O 流类 & 功能 \\
\hline
BufferedStream & \small 用于给其他的流添加缓冲，提高性能 \\
CryptoStream & \small 在 ~System.Security.Cryptography 中，用于加密 \\
MemoryStream & \small 在内存中直接访问所封装的数据 \\
NetworkStream & \small 在 ~System.Net.Sockets 中，用于封装网络连接上的流 \\
FileStream & \small 基本的文件操作类 \\
\hline
\end{tabular}

\end{frame}

\begin{frame}
\frametitle{FileStream 类}
\CJKindent FileStream 是对文件进行读取、写入和关闭操作，对管道、标准输入输出等设备的操作。
\begin{figure}
  \centering
  \input{pgf/lib-filestream}
\end{figure}
\begin{itemize}
\item FileMode 指定文件的打开方式
\item FileAccess 指定文件的访问方式
\item FileShare 指定文件的共享方式
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{FileStream 示例}
\lstset{emph={WriteByte,ReadByte,Position,Length}}
\begin{lstlisting}[escapeinside=<>]
FileStream fs = new FileStream (@"C:\abc.txt", 
    FileMode.OpenOrCreate, FileAccess.ReadWrite);
byte[] data = new byte[5]{65,66,67,68,69}; // ABCDE

foreach (byte b in data){
  fs.WriteByte(b);}

fs.Position = 0; 

for (int i=0; i<fs.Length; i++)
  Console.Write((char) fs.ReadByte());

fs.Close();
\end{lstlisting}
\begin{itemize}
\item \texttt{fs.Position} 直接定位当前位置
\item \texttt{fs.Length} 直接取得文件长度
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{MemoryStream 类}
\CJKindent MemoryStream 主要用于临时数据存储，在内存中使用流的方式处理数据。
\begin{lstlisting}[escapeinside=<>]
// <使用> MemoryStream <缓冲一个文件>
FileStream fsIn = new FileStream(...);

MemoryStream ms = new MemoryStream();
int oneByte;

while ((oneByte = fsIn.ReadeByte()) != -1){
  ms.WriteByte ((byte)oneByte);
}
fsIn.Close();

// <流> ms <中的内容和文件一样，但效率更高>

\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{BufferedStream 类}

\end{frame}

\begin{frame}
\frametitle{TextReader/TextWriter}

\end{frame}

\begin{frame}
\frametitle{StringReader/StringWriter}

\end{frame}

\begin{frame}
\frametitle{BinaryReader/BinaryWriter}

\end{frame}

\begin{frame}
\frametitle{Stream 之间的区别}
\begin{itemize}
\item Byte-Oriented File I/O
\item Character-Based File I/O
\item Binary Data I/O
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Console I/O}

\end{frame}


\section{串行化}



\section{网络通信}



% Local Variables:
% mode: LaTeX
% TeX-master: "part-04.tex"
% TeX-header-end: "% End-of-Header$"
% TeX-trailer-start: "% Start-of-Trailer$"
% coding: gb2312-dos
% End:
