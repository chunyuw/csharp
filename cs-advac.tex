%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn>

\part{C\# 高级特性}

\section{抽象类和接口}

\begin{frame}[fragile,t]
\frametitle{抽象类}
\begin{onlyenv}<1>
  \begin{itemize}
  \item 用 abstract 修饰，不能生成实例
  \item 可以只给出方法的声明，无具体实现
  \item 而具体实现由派生类完成
  \end{itemize}
\end{onlyenv}
\begin{onlyenv}<1-2>
  \lstset{emph={abstract}}
\begin{lstlisting}
public abstract class Graphics{
  public static double pi = 3.14159;
  public abstract double Area();
  public abstract double Perimeter();
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<2>
  \lstset{emph={override}}
\begin{lstlisting}
class Circle:Graphics {
  public int r = 2;
  public override double Perimeter(){
    return 2 * pi * r;
  }
  public override double Area(){
    return pi * r * r;
  }
}
\end{lstlisting}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile]
\frametitle{接口(interface)}
\begin{onlyenv}<1> 
  \begin{block}{接口}
    能声明特性、索引器、事件和方法的特殊结构，只为这些成员提供定义，没有具体
    实现。
  \end{block}
\end{onlyenv}
\begin{onlyenv}<1-3>
  \lstset{emph={interface},emph={[2]Perimeter,Area}}
\begin{lstlisting}
public interface IMeasurement{
  double Area();
  double Perimeter();
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<2>
  \lstset{emph={[2]Perimeter,Area}}
\begin{lstlisting}
class    Circle:IMeasurement {
  public int r = 2;
  public static double pi = 3.14159;
  public double Perimeter(){
    return 2 * pi * r;
  }
  public double Area(){
    return pi * r * r;
  }
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<3>
  \lstset{emph={[2]Perimeter,Area}}
\begin{lstlisting}
class Rectangle:IMeasurement {
  public int width,height;
  public double Perimeter(){
    return 2 * (width + height);
  }
  public double Area(){
    return width * height;
  }
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<4>
  \begin{block}{接口的特点}
    \begin{itemize}
    \item 为类提供了蓝图，规范了类之间的交互方式
    \item 可以继承其他接口
      \lstset{emph={MyIf},emph={[2]BaseIf}}
\begin{lstlisting}
public interface MyIf:BaseIf
  { ... }
\end{lstlisting}
    \item 和抽象类一样，不可以生成实例
    \item 接口成员默认为 public 和 abstract
    \end{itemize}
  \end{block}
\end{onlyenv}
\begin{onlyenv}<5>
  \begin{block}{接口和抽象类的区别}
    \begin{itemize}
    \item 只有四种成员，仅提供定义而不实现
    \item 定义不需要 public 和 abstract，实现不需要 override
    \item 类只能继承一个类，但可以实现多个接口
      \lstset{emph={MyClass},emph={[2]FirstIf,AnotherIf}}
\begin{lstlisting}
class MyClass:FirstIf,AnotherIf
  { ... }
\end{lstlisting}
    \end{itemize}
  \end{block}
\end{onlyenv}
\end{frame}

\section{委托和事件}
\begin{frame}
\frametitle{委托}

\end{frame}

\begin{frame}
\frametitle{事件}

\end{frame}

\section{索引器}
\begin{frame}
\frametitle{索引器}

\end{frame}

\section{泛型}
\begin{frame}
\frametitle{泛型}

\end{frame}



% Local Variables: 
% mode: LaTeX
% TeX-master: "lesson-02.tex"
% TeX-header-end: "% End-Of-Header$"
% TeX-trailer-start: "% Start-Of-Trailer$"
% coding: gb2312-dos
% End:
