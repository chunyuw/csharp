%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn>

\part{C\# 高级特性}

\section{抽象类和接口}

\begin{frame}[fragile,t]
\frametitle{抽象类}
\begin{onlyenv}<1>
  \begin{itemize}
  \item 用 abstract 修饰，不能生成实例
  \item 可以只给出方法的声明，无具体实现
  \item 而具体实现由派生类完成
  \end{itemize}
\end{onlyenv}
\begin{onlyenv}<1-2>
  \lstset{emph={abstract}}
\begin{lstlisting}
public abstract class Graphics{
  public static double pi = 3.14159;
  public abstract double Area();
  public abstract double Perimeter();
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<2>
  \lstset{emph={override}}
\begin{lstlisting}
class Circle:Graphics {
  public int r = 2;
  public override double Perimeter(){
    return 2 * pi * r;
  }
  public override double Area(){
    return pi * r * r;
  }
}
\end{lstlisting}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile]
\frametitle{接口(interface)}
\begin{onlyenv}<1> 
  \begin{block}{接口}
    能声明特性、索引器、事件和方法的特殊结构，只为这些成员提供定义，没有具体
    实现。
  \end{block}
\end{onlyenv}
\begin{onlyenv}<1-3>
  \lstset{emph={interface},emph={[2]Perimeter,Area}}
\begin{lstlisting}
public interface IMeasurement{
  double Area();
  double Perimeter();
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<2>
  \lstset{emph={[2]Perimeter,Area}}
\begin{lstlisting}
class    Circle:IMeasurement {
  public int r = 2;
  public static double pi = 3.14159;
  public double Perimeter(){
    return 2 * pi * r;
  }
  public double Area(){
    return pi * r * r;
  }
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<3>
  \lstset{emph={[2]Perimeter,Area}}
\begin{lstlisting}
class Rectangle:IMeasurement {
  public int width,height;
  public double Perimeter(){
    return 2 * (width + height);
  }
  public double Area(){
    return width * height;
  }
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<4>
  \begin{block}{接口的特点}
    \begin{itemize}
    \item 为类提供了蓝图，规范了类之间的交互方式
    \item 可以继承其他接口
      \lstset{emph={MyIf},emph={[2]BaseIf}}
\begin{lstlisting}
public interface MyIf:BaseIf
  { ... }
\end{lstlisting}
    \item 和抽象类一样，不可以生成实例
    \item 接口成员默认为 public 和 abstract
    \end{itemize}
  \end{block}
\end{onlyenv}
\begin{onlyenv}<5>
  \begin{block}{接口和抽象类的区别}
    \begin{itemize}
    \item 只有四种成员，仅提供定义而不实现
    \item 定义不需要 public 和 abstract，实现不需要 override
    \item 类只能继承一个类，但可以实现多个接口
      \lstset{emph={MyClass},emph={[2]FirstIf,AnotherIf}}
\begin{lstlisting}
class MyClass:FirstIf,AnotherIf
  { ... }
\end{lstlisting}
    \end{itemize}
  \end{block}
\end{onlyenv}
\end{frame}

\section{委托和事件}
% \begin{frame}[fragile]
% \frametitle{委托(delegate)}
% \begin{onlyenv}<1>
%   \begin{block}{委托}
%     具有特定返回类型和参数列表的方法的引用类型；方法可以有任何名字，可以使静
%     态或实例方法；对方法实际能进行的操作没有限制。
%   \end{block}
%   \begin{itemize}
%   \item 定义委托后，需要声明及创建委托的实例
%   \item 通过委托，程序可以在运行时动态的调用不同的方法
%   \end{itemize}
% \end{onlyenv}
% \begin{onlyenv}<2>
% \begin{lstlisting}[escapeinside=<>]
% // <定义委托 Compute>
% delegate int Compute (int a, int b);
% class Test {
% public Compute comp;        // <声明委托>
% public int add (int x, int y)
% { return x + y; }
% } ...
% Test n = new Test();
% n.comp = new Compute(n.add); // <创建委托实例>
% int r  = n.comp3 (20,40);    // <调用委托>
% System.Console.WriteLine (r);
% \end{lstlisting}
% \end{onlyenv}
% \end{frame}

% \begin{frame}[fragile]
% \frametitle{事件}
% \begin{itemize}
% \item ...
% \end{itemize}
% \end{frame}
\begin{frame}
\frametitle{委托}

\end{frame}

\begin{frame}
\frametitle{事件}

\end{frame}

\section{泛型}
  \begin{frame}[fragile]
\frametitle{泛型}
\begin{block}{\textit{Generics}}
  \CJKindent 泛型就是将类型为参数，可以动态设置的类，类似 ~C++ 中的模板类。
  泛型是 ~.NET 2.0 的新特性。
\end{block}
\pause
\begin{itemize}
\item 
\item 
\end{itemize}
\pause
泛型定义的一般格式
\begin{lstlisting}
class identifier<type-param-list> 
         [where type-param:constraints]
{ ... }
\end{lstlisting}
泛型使用的一般格式
\begin{lstlisting}
identifier<type-arg-list>  var-name =
  new  class-name<type-arg-list>(cons-arg-list);
\end{lstlisting}
\end{frame}

% Local Variables: 
% mode: LaTeX
% TeX-master: "part-02.tex"
% TeX-header-end: "% End-Of-Header$"
% TeX-trailer-start: "% Start-Of-Trailer$"
% coding: gb2312-dos
% End:
