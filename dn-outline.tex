%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn>

\section{.NET 平台}
\begin{frame}
\frametitle{什么是 ~Microsoft .NET} 

  \CJKindent .NET 是 ~Microsoft 的用以创建 ~XML Web 服务平台，该平台将信息、设
  备和人以一种统一的、个性化的方式联系起来。

  \smallskip

  借助于 ~.NET 平台，可以创建和使用基于 ~XML 的应用程序、进程和 ~Web 站点以及服
  务，它们之间可以按设计、在任何平台或智能设备上共享和组合信息与功能，以向单位
  和个人提供定制好的解决方案。
  
  % Microsoft .NET 扩展了通过任何设备随时随地操作数据和进行通讯的能力。.NET 使
  % 用分布式计算模型并基于开放标准（如 XML）将 PC 与其他智能设备连接在一起。

  % XML 是 Internet 上数据交换的通用语言。它提供了一个广泛包容的、开放标准的技
  % 术，用于数据交换和转换，克服了应用程序和服务互操作性和集成面临的障碍。
  
  \begin{uncoverenv}<2-| handout:1>
    \begin{itemize}
    \item 一组用于创建互联网操作系统的构建块，其中包括 ~Passport .NET 以及用于
      文件存储的服务、用户首选项管理、日历管理以及众多的其它任务
    \item 构建和管理新一代服务的基本结构和工具，包括 ~Visual Studio .NET, .NET
      企业服务器、 .NET 框架和 ~Windows .NET
    \item 能够启用新型智能互联网设备的 ~.NET 设备软件
    \item 功能丰富而自然的用户界面，个人信息管理和控制，一系列全新的 ~.NET 用户
      体验
    \end{itemize}
  \end{uncoverenv}
    % http://www.microsoft.com/china/press/2000/06/0627a.mspx

  % \begin{itemize}
  % \item Microsoft .NET Framework
  % \item Microsoft Visual Studio
  % \end{itemize}

\end{frame}

\begin{frame}
\frametitle{Microsoft .NET 平台的设计目标}
\CJKindent

Microsoft .NET 平台利用以互联网为基础的计算和通讯激增的特点，通过先进的软件，
利用网络协议和格式，协调众多的智能设备与网站，从而提供更简单、更为个性化、更
有效的互联网服务。.NET 为一个集成环境，可以在 ~Internet，Windows 桌面以及移动
设备上进行无缝地开发和运行应用程序。

  \begin{itemize}
  \item 提供一个覆盖整个应用范围的、一致的面向对象环境
  \item 简化代码的发布/安装过程，最小化版本冲突问题
    % DLL Hell
  \item 基于公认的标准，提供一个可移植的环境
    % C\# 和 .NET CLI 已经得到了 ECMA (欧洲计算机制造协会) 的标准化.
  \item 提供一个可管理的环境，保证程序的安全执行
  \end{itemize}
  % 兼容 Win32 API 和 COM

\end{frame}

\begin{frame}[t]
\frametitle{Microsoft .NET 相关技术标准}
  \begin{itemize}
    \CJKindent
  \item<1-| handout:1> XML\only<1| handout:0>{, \textit{eXtensible Markup Language}} 
    \only<2-| handout:1>{--- 基于 ~Web 的结构化数据的通用格式}
    \medskip

    \only<1| handout:0>{\small XML 是一组设计文本数据格式的规则，所产生的文件意义明确并且独立于平台，
      方便生成和（被计算机）读取。当前，如果一个 ~Web 应用程序要从另一个应用程序那里检索数据，它必须
      借助“屏幕搜索”- 捕获带有它所需数据的屏幕图片，并试图弄清如何把图片解释回数据。这样做效率非常
      低，并且容易产生错误。XML 为 ~XML Web 服务提供了一种格式，使其能够交换实际数据而不是包含数据的
      图片。}

  \item<2-| handout:1> SOAP\only<2| handout:0>{, \textit{Simple Object Access Protocol}}
    \only<3-| handout:1>{--- 简单对象访问协议}
    \medskip

    \only<2| handout:0>{\small 它使应用程序可以通过一种标准的，松耦合的方式相互调用，这使生成
      在 ~Internet 上分发的应用程序成为可能。

      如果将 ~XML Web 服务之间的交互想象成电话通话，则 ~XML 描述了应用程序在它们的对话中相互所说的内
      容，SOAP 则描述了它们在电话里是如何呼叫对方的。}

    % 与 XML 一样，SOAP 是 W3C 标准过程的一部分，是由 Microsoft 和包括 IBM 在内
    % 的很多其他公司联合建议的。 XML 和 SOAP 实际上已经得到了业内主要软件供应商
    % 的公开认可，包括 Microsoft, IBM, HP, Sun 和 Oracle。

  \item<3-| handout:1> UDDI\only<3| handout:0>{, \textit{Universal Description, Discovery and Integration}}
    \only<4-| handout:1>{--- 统一描述、发现和集成}
    \medskip

    \only<3| handout:0>{\small 如果 ~XML 是对话，SOAP 描述呼叫他人的规则，那么 ~UDDI 就是电话号码
      簿。UDDI 提供了一个 ~XML Web 服务的目录，便于查找提供 ~XML Web 服务的企业。}

  \item<4-| handout:1> WSDL\only<4| handout:0>{, \textit{Web Services Description Language}}
    \only<5-| handout:1>{--- Web 服务描述语言}
    \medskip

    \only<4| handout:0>{\small WSDL 提供了一个标准方法，用以描述一个特定 ~XML Web 服务提供何种函数，
      以及调用这些函数时必须传递哪些参数。与 ~XML, SOAP 一样， WSDL 也已经提交给 ~W3C 进行标准化。}

  \item<5-| handout:1> C\# 和 ~CLI\only<5| handout:0>{, \textit{Common Language Infrastructure}}
    \only<6-| handout:1>{--- .NET 框架的一部分}
    \medskip

    \only<5| handout:0>{\small Microsoft 为 ~XML Web 服务家族创建的一种编程语言 ~C\#。并且已经提交
      给 ~ECMA 进行标准化。 Microsoft 还向 ~ECMA 提交了 ~Microsoft .NET 框架的一个子集，叫做公共语言
      基础结构 (CLI)。这将使其他供应商能够在各种平台上实现 ~CLI，以便用 ~.NET 框架提供的基本体系结构
      模型所写的软件可以在各种平台上用各种工具来创建。}

  \end{itemize}
  \medskip

  \only<6| handout:1>{\CJKindent Microsoft 致力于为支持 ~.NET 的主要技术制订标准。使软件能
    够交互操作和交换数据的技术标准化，将使涉及多种操作平台的解决方案成为可能，
    从而使最终用户受益。}

\end{frame}

% 对于开发人员而言，丰富的类库，方便的集成，以及发布、部署和维护方便性显得尤为
% 重要

\begin{frame}
\frametitle{公共语言基础结构}
  \framesubtitle{实现 ~.NET 平台的基础}
  \begin{block}{\textit{Common Language Infrastructure(CLI)}}
    \CJKindent CLI 定义了一个与平台无关的虚拟代码执行环境。包括公共中间语言和公
    共类型系统，相应的语法、语义和部分 ~.NET 框架类库。
  \end{block}
  \begin{itemize}
  \item<2-| handout:1> CLI 中没有指定操作系统，可以在任何的系统或设备上实现
  \item<3-| handout:1> 其他公司也可以根据 ~CLI 标准实现相关技术
    \begin{itemize}
    \item Microsoft .NET Framework -- 微软公司自己的实现
    \end{itemize}
  \item<4-| handout:1> 目前已有的开源 ~.NET 平台
    \begin{itemize}
    \item Mono Project --- http://www.mono-project.com
    \item DotGNU Project --- http://www.dotgnu.org
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[t]
\frametitle{Web 服务}
  \begin{block}{\textit{Web Services}}
    {\CJKindent Web Services 是可远程访问的应用程序组件，并且响应以 ~HTTP 为主访
      问请求，提供基于文本的信息服务。}
  \end{block}
  \begin{itemize}
  \item 提供了信息发布的标准方式，方便应用程序访问
  \item 信息不再是网页或文件，以根据需要各取所需
  \item 消除了使用不同组件模型、操作系统之间存在的差异
  \item 方便创建基于 ~Web 服务的分布式应用程序
  \end{itemize}
\end{frame}

\begin{frame}[fragile,t]
\frametitle{Web 服务示例}

  \begin{itemize}
  \item http://www.webservicex.net/globalweather.asmx
  \item \only<1| handout:1>{通过 ~SOAP 的访问} \only<2| handout:0>{返回的结果}
  \end{itemize}

  \begin{onlyenv}<1| handout:1>
\begin{lstlisting}[language=XML, showstringspaces=false]
POST /globalweather.asmx HTTP/1.1
Host: www.webservicex.net
Content-Type: text/xml; charset=utf-8
Content-Length: length
SOAPAction: "http://www.webserviceX.NET/GetWeather"

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi= ... >
 <soap:Body>
  <GetWeather xmlns="http://www.webserviceX.NET">
   <CityName>Harbin</CityName>
   <CountryName>China</CountryName>
  </GetWeather>
 </soap:Body>
</soap:Envelope>
\end{lstlisting}
  \end{onlyenv}

  \begin{onlyenv}<2| handout:0>
\begin{lstlisting}[language=XML, showstringspaces=false]
HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi= ... >
 <soap:Body>
  <GetWeatherResponse 
           xmlns="http://www.webserviceX.NET">
   <GetWeatherResult>string</GetWeatherResult>
  </GetWeatherResponse>
 </soap:Body>
</soap:Envelope>
\end{lstlisting}
  \end{onlyenv}
\end{frame}

\section{ .NET 框架简介}

\begin{frame}
\frametitle{Microsoft .NET Framework}
  \framesubtitle{功能丰富的开发平台}
  \begin{itemize}
  \item \large 互联网、分布式应用程序、Windows 应用程序
  \item \large 创建与运行 ~Windows 应用程序的基础
  \item \large 创建与使用 ~Web Services 的工具
  \item \large 便携设备的开发和运行的环境
  \end{itemize}
\end{frame}

\begin{frame}[t]\frametitle{Microsoft .NET Framework}
  \framesubtitle{功能丰富的开发平台}
  \begin{exampleblock}{提供了丰富的类库}
    \begin{columns}
      \column{4cm}
      \begin{itemize}
      \item ASP.NET
      \item Windows Forms
      \item Enterprise Services
      \end{itemize}
      \column{4cm}
      \begin{itemize}
      \item ADO.NET
      \item Web Services
      \item ...
      \end{itemize}
    \end{columns}
  \end{exampleblock}
  \begin{onlyenv}<2| handout:0>
    \begin{itemize}
    \item 充分利用代码复用，简化了应用程序的开发
    \item 类库提供开发所需的各种基本功能，可以支持各种类型的应用程序
    \item 类库屏蔽了底层细节，统一了编程模式，易于使用
    \item 容易维护、部署等
    \end{itemize}
  \end{onlyenv}
  \begin{onlyenv}
    \begin{block}<3| handout:1>{完整的安全解决方案}
      \begin{itemize}
      \item 基于证据的安全规则，确保组件的来源可靠
      \item 细致的权限设置，可以为组件设置不同权限
        \begin{itemize}
        \item 访问注册表
        \item 文件读取
        \item 访问网络
        \end{itemize}
      \end{itemize}
    \end{block}
  \end{onlyenv}
\end{frame}

\begin{frame}
\frametitle{.NET 框架的组成}
  \begin{itemize}
  \item 公共语言运行时 --- \textit{Common Language Runtime}
  \item .NET 框架类库 --- \textit{Framework Class Library}
    % 组成的内容 (文字)
  \end{itemize}

  \only<1| handout:1>{\label{fig:dn-framework}}
    \centering \input{pgf-dn/dn-framework} % .NET 框架的层次图 (图)

\end{frame}

% 多种语言之间的交互

\section{公共语言运行时}
\begin{frame}
\frametitle{公共语言运行时}
  \begin{block}{\textit{Common Language Runtime(CLR)}}
    \CJKindent 全部 ~.NET Framework 的基础，为 ~.NET 程序提供了一个虚拟机环境，
    以支持进程的创建和执行，托管代码和非托管代码的交互，为进程提供必要的服务。
  \end{block}

  % \begin{figure}[h] \only<1-| handout:1>{\label{fig:clr-compile-exec}}
  %   \centering \input{pgf-dn/clr-compile-exec}
  % \end{figure}

  \begin{itemize}
  \item<2-| handout:1> CLR 要管理\alert<2| handout:0>{托管代码}的整个运行周期：查找代码、编译、加载相
    关的类、运行、自动内存管理
  \item<3-| handout:1> 提供多种语言都支持的\alert<3| handout:0>{公共类型系统}，定义如何声
    明和管理 ~CLR 中的类型
  \item<4-| handout:1> 支持跨语言集成，允许不同语言生成的代码能够无缝地交互
  \item<5-| handout:1> 管理类型系统的安全，管理组件的安全
  \item<6-| handout:1> 负责访问其他系统资源，提供 ~Win32 API, COM 等访问接口
  \end{itemize}

  % \begin{itemize}
  % \item 提供通用类型系统 (CTS)\\
  %   值类型：整数、浮点数、结构体等\\
  %   引用类型：类对象、委托、接口等
  % \item 为托管代码执行提供服务\\
  %   智能内存管理，元数据管理，受管库的加载与分析，处理异常，代码互操作
  % \item 访问系统资源\\
  %   Win32 API 或 COM 等
  % \end{itemize}

\end{frame}

\begin{frame}
\frametitle{托管代码}

\begin{block}{\textit{Managed Code}}
\CJKindent 托管代码是由面向 ~CLR 的编译器生成，支持公共语言运行时服务的代码，为了支持这些服务，代码必须向运行时提供最小级
别的信息，即元数据 (\textit{metadata})。
\end{block}

\begin{itemize}
\item<2-| handout:1> 托管代码的运行受 ~CLR 控制，如内存分配、类型检查、安全验证、垃圾回收等
\item<3-| handout:1> 由公共语言运行时的垃圾回收器进行分配和释放的数据，称为托管数据
\item<4-| handout:1> 默认情况下，所有 ~C\#, Visual Basic.NET 和 ~JScript.NET 代码都是托管代码
\item<5-| handout:1> Visual Studio.NET C++ 默认情况下不是，但通过编译器命令行开关 (\texttt{/CLR})，也可以生成托管代码。
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{CLR 虚拟机}
  \begin{itemize}
  \item<1-| handout:1> CLR 相当于一种虚拟机，独立于操作系统或体系结构
  \item<2-| handout:1> .NET 编译器生成 ~Windows PE (\textit{Portable Executable}) 文件，扩展名通常
    为 ~DLL 或 ~EXE
  \item<3-| handout:1> Windows PE 文件实际内容是面向 ~CLR 的中间语言文件，以及执行所需的 ~CLR 文件头
  \item<4-| handout:1> 当执行时，通过调用 ~JIT (\textit{Just-In-Time}) 编译器，实时编译为本地代码
    (\textit{native code})
  \end{itemize}

  \begin{figure}[h] \only<1| handout:1>{\label{fig:clr-compile-exec}}
    \centering \input{pgf-dn/clr-compile-exec}
  \end{figure}
\end{frame}


\begin{frame}
\frametitle{公共类型系统}

  \begin{block}{\textit{Common Type System(CTS)}}
    \CJKindent CTS 是一组预定义的类型和这些类型行为的规范，描述了如何声明和创建
    定制类型，如何管理这些类型实例的生命周期，以及怎样才能得到 ~CLR 的支持。
  \end{block}

  \begin{uncoverenv}<2-| handout:1>
    \begin{itemize}
    \item 定义了声明、使用和管理定制或预定义类型的标准化框架
    \item 使不同的编程语言之间的能够集成
    \item 遵循 ~CTS 能够保障类型的安全和性能的优化
    \item 遵循 ~CTS 的语言不一定支持 ~CTS 中定义的全部类型
    \end{itemize}
  \end{uncoverenv}
\end{frame}

\begin{frame}[c]
\frametitle{CTS 的类型结构}

  % 所有的类型都派生自Objects类型，而所有的值类型都派生自ValueTypes类型。
\begin{figure}[h]  \only<1| handout:1>{\label{fig:cts-typesystem}}
  \centering  \input{pgf-dn/cts-typesystem}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{值类型和引用类型}
%   值类型和引用类型的区别：
% http://msdn2.microsoft.com/en-us/library/2hf02550.aspx
\begin{itemize}
\item<1-| handout:1> \small CLR 是一种基于栈的虚拟机，并维护一个用于创建对象的堆
\item<2-| handout:1> \small 函数调用时自动分配的内存在栈中，当函数返回时自动释放
\item<3-| handout:1> \small 自由创建的对象在堆中，栈中只有堆中地址的引用 (\textit{reference}) \\
  \small 堆中分配的对象不会自动释放，而是由垃圾回收负责
\item<4-| handout:1> \small 在栈中分配的变量是值类型的，而堆中的是引用类型
\end{itemize}

\begin{columns}
  \column{.5\textwidth}
  \begin{figure}[h] \only<1| handout:1>{\label{fig:cts-v-r-types}} 
    \centering \input{pgf-dn/cts-v-r-types}
  \end{figure}
  \column{.5\textwidth}
  \begin{itemize}
  \item<1-| handout:1> \small 托管栈 --- \textit{Managed Stack}
  \item<1-| handout:1> \small 托管堆 --- \textit{Managed Heap}
  \item<4-| handout:1> \small 值类型 --- \textit{Value Type}
  \item<4-| handout:1> \small 引用类型 --- \textit{Reference Type}
  \end{itemize}

\end{columns}
  % 托管代码执行过程中，变量可以在托管栈或托管堆中分配。
  % 当方法被调用时，局部变量或方法创建的值类型变量都在栈中分配，当方法运行结束时都自动的释放；           
  % 而在堆中分配的变量，并不自动释放，而是通过“垃圾处理”来由CLR管理并释放。

  % 值类型的变量在栈中分配，而引用类型的变量在栈中只有一个引用，指向在堆中实际内存

\end{frame}

\begin{frame}
\frametitle{公共语言规范}
  \begin{block}{\textit{Common Language Specification(CLS)}}
    \CJKindent 语言互操作的最终规范，定义了遵循 ~CLR 的编译器必须包含的最小特性集，保证语
    言之间的通信。% CTS 的一个子集。
  \end{block}

  \begin{exampleblock}{部分 ~CLS 特性和规则}<2-| handout:1>
    %\rowcolors{1}{RoyalBlue!20}{RoyalBlue!5}
    \begin{tabular}{l|l}
      \hline
      \multicolumn{1}{c|}{\hei特\ \ 性} & \multicolumn{1}{c}{\hei 规\ \ 则}\\\hline
      可见性       & 定义类型的程序集之外有效 \\
      字符和大小写 & 变量除了大小写不同之外，还需要有其他区别 \\
      基本类型     & Byte, Int, Single, Double, Boolean 等 \\
      构造函数调用 & 访问实例数据前，必须调用基类的构造函数 \\
      数组边界     & 数组的各个维下界必须为 ~0 \\
      枚举         & 基类型必须是 ~Byte, Int16, Int32 或 ~Int64 \\
      方法签名     & 签名中返回值和参数的类型必须遵循 ~CLS \\
    \end{tabular}
  \end{exampleblock}

\end{frame}

%\subsection*{托管代码的编译}
\begin{frame}<0| handout:0>
\frametitle{CLR 中程序的运行}
  \begin{itemize}
  \item CLR 定义了一种基于栈的虚拟机
  \item CLR 上执行的代码是 ~CIL 编写的托管代码
  \item CIL 通过 ~JIT 实时的编译为本地代码
  \item CLR 是负责托管代码执行的虚拟运行环境
  \item MSIL 是 ~CIL 的一种实现
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Microsoft 中间语言}
%什么是 Microsoft 中间语言 (MSIL)？

\begin{block}{\textit{Microsoft Intermediate Language}}
  \CJKindent MSIL 是与 ~CPU 无关的指令集，它包含加载、存储、初始化和调用对象方法
  的指令，相当于 ~CLR 的汇编语言。
\end{block}

\begin{itemize}
\item \small .NET 框架程序被编译成生成 ~MSIL 和元数据
\item \small MSIL，元数据，CTS 结合，允许真正的跨语言集成
\item \small MSIL 在执行前被转换为机器代码，而不是边解释边执行
\end{itemize}

\begin{figure}[h] \only<1| handout:1>{\label{fig:clr-compile}}
  \centering \input{pgf-dn/clr-compile}
\end{figure}

\end{frame}

\begin{frame}
\frametitle{托管代码的实时编译}
\begin{overlayarea}{\textwidth}{1.2cm}
  \begin{itemize}
  \item \small
    \only<1| handout:0> {当托管代码调用其他模块或方法时， ~CLR 自动寻找并将其加载}
    \only<2| handout:0> {然后跳转到该方法的入口，首先调用 ~\texttt{\_CorExeMain()} 方法，通过它检查当前代
      码是否已经被编译为本地代码}
    \only<3| handout:0> {如果没有编译，则调用 ~JIT 编译器，把当前方法的 ~MSIL 编译为本地代码}
    \only<4| handout:0> {并将原来加载 ~MSIL 代码替换为本地代码}
    \only<5| handout:0> {因为已经替换了内存中的内容，所以 ~MSIL 加载之后，只需编译一次 }
    \only<6| handout:0> {当方法再次被调用时，可以直接执行，不需再次编译}
    \only<0| handout:1> {已经编译的本地代码会替换内存中的 ~MSIL，因此无需再次编译}
  \end{itemize}
\end{overlayarea}

\begin{figure}[h] \only<1| handout:1>{\label{fig:clr-execute}}
  \centering \input{pgf-dn/clr-execute}
\end{figure}

\end{frame}

% 程序集
% 什么是程序集？

% 程序集是 .NET 框架应用程序的主要构造块。它是作为一个单一实现单元（包含一个或多
% 个文件）来创建、标识和部署的功能集合。所有的托管类型和资源都可以被标记为仅在其
% 实现单元内访问，或者标记为可由该单元以外的代码来访问。

% 程序集通过清单来进行自我说明。清单是每个程序集的不可或缺的组成部分。清单：

% 建立程序集标识（以文本名称的格式）、版本、类别和数字签名（如果要在应用程序之间
% 共享该程序集）。

% 定义组成程序集实现的文件（通过名称和文件散列）。

% 指定组成程序集的类型和资源，包括哪些是从程序集中导出的。

% 逐条记录编译时对其他程序集的依存。

% 指定程序集正确运行所需要的权限的集合。

% 此信息在运行时用于解析引用、强制版本绑定策略以及验证所加载的程序集的完整性。因
% 为每一类型都被加载到程序集的上下文中，所以运行时可以确定并定位任何正在运行的对
% 象的程序集。程序集也是应用了代码访问安全权限的单元。在确定授予其所包含的代码哪
% 些权限时，每个程序集的标识证据都被认为是独立的。

\begin{frame}
\frametitle{程序集}
  \begin{block}{\textit{Assembly}}
    \CJKindent \small .NET 框架应用程序中，由一个或一组文件构成的，单一功能的
    逻辑单元。程序集是组件复用，实施安全策略的最小单位。
  \end{block}
  \begin{itemize}
  \item 程序集可以有一个或多个文件
  \item 程序集都有一个{\color<handout:0>{red!65!black}清单} (\textit{manifest}{})
  \item 清单描述程序集的内容信息
    \begin{enumerate}
    \item 程序集的名字
    \item 版本号，形如 ~major.minor.build.revision
    \item 支持的语言
    \item 程序集其他文件列表
    \item 所依赖的其他程序集及版本号
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}[t]
\frametitle{程序集的清单}

  \begin{itemize}
  \item 清单就是程序集的元数据，描述程序集包含的内容
  \item 如 ~DLL 文件，EXE 文件，图片文件，数据文件等
  \item 而程序集的清单只在其中一个文件中
  \end{itemize}

  \begin{onlyenv}<2-| handout:1>
    \begin{center}
      \includegraphics{assembly1.pdf}
    \end{center}
  \end{onlyenv}
\end{frame}

\begin{frame}
\frametitle{程序集的功能}
  \begin{itemize}
  \item 程序集定义了类型的有效范围， ~CLR 通过程序集查找类
  \item 程序集不需要注册表项， ~CLR 通过一种算法查找程序集 
  \item 安装 ~.NET 应用程序，只拷贝它的程序集即可
    % 安装与卸载 ~.NET 模块不需要修改系统注册表，只需 ~copy or delete
  \item 程序集可以有一个增强型名称 (\textit{Strong name})，用作共享名称
    \begin{itemize}
    \item 除了三个必须的成员之外，还要有数字签名和相应的公钥
    \item 通过数字签名，可以确保程序集的唯一性，增加安全性
    \end{itemize}

  \item 允许不同版本的程序集并存，可有效避免 ~DLL Hell
    % 因为程序集需要指定版本号，而程序集的依赖也如此
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{程序集的种类}
% http://www.microsoft.com/china/msdn/archives/library/faq111700.asp

\begin{block}{专用程序集}
  \CJKindent \small 专用程序集仅由单一应用程序使用，并且存储在该应用程序的安装目录中（或其子目录中）。要求在使
  用它的应用程序中是唯一的。
\end{block}

\begin{block}{共享程序集}
  \CJKindent \small 共享程序集是可被多个应用程序引用的程序集，通常被明确安装在全局程序集缓存 (\textit{Global
    Assembly Cache, GAC})中。要共享一个程序集，该程序集必须明确为这个目的而创建，这可以通过给其指定加密的增强型名称
  来实现。
\end{block}

\begin{itemize}
\item 通过区分专用和共享程序集，确定如何部署 (\textit{Deploy}) 程序集
\item 根据增强型名称，判断是否接受程序集，或新的版本
\item 根据版本管理特性，保证下载的代码不会影响本地应用程序的执行
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{程序集的加载过程}
  \begin{itemize}
  \item 只有在需要的时候加载，程序集可以在本地或网络中
    % 如果依赖程序集没有调用，不会被加载；
    % 程序集甚至不需在目标机器上

  \item CLR 通过特定的规则寻找需要的程序集
    
    \begin{enumerate}
    \item CLR 检查是否已经被加载，如果已经加载，结束查找
    \item 在全局程序集缓存(GAC)中查找
    \item 在程序代码中指定的位置查找
    \item 如果代码没有指定，在应用程序目录查找
    \item 根据 ~.NET 的配置，在其他目录或 ~URL 查找
    \item 如果都未找到，报告错误，结束查找
    \end{enumerate}

  \item 找到程序集后，检查增强名(如果有)，加载并使用
  \end{itemize}
\end{frame}


\begin{frame}
\frametitle{应用程序域}
\begin{block}{\textit{App Domain}}
  \CJKindent 应用程序域为安全性、可靠性、版本控制以及卸载程序集提供了隔离边界。应用程序域通常由运行库
  宿主创建，运行库宿主负责在运行应用程序之前引导公共语言运行库。
\end{block}
\begin{itemize}
\item 加载 ~CLR 的程序称为{\color<handout:0>{red!65!black}运行库宿主} (\textit{runtime host})
\item 应用程序域，由运行库宿主创建
\item 宿主依靠{\color<handout:0>{red!65!black}验证} (\textit{verification})来隔离程序集
\item 在一个应用程序域中出现的错误不会影响其他应用程序域
\end{itemize}
\end{frame}
% \begin{itemize}
% \item 在一个应用程序中出现的错误不会影响其他应用程序\par
%   \CJKindent \small 因为类型安全的代码不会导致内存错误，所以使用应用程序域可以确保在一个域中运行的代
%   码不会影响进程中的其他应用程序。
% \item 能够在不停止整个进程的情况下停止单个应用程序\par
%   \CJKindent \small 使用应用程序域使可以卸载在单个应用程序中运行的代码。不能卸载单个程序集或类型。只
%   能卸载整个域。
% \item 在一个应用程序中运行的代码不能直接访问其他应用程序中的代码或资源
% \item 代码行为的作用范围由它运行所在的应用程序决定\par
%   \CJKindent \small 换言之，应用程序域将提供应用程序版本策略等配置设置、它所访问的任意远程程序集的位
%   置，以及加载到该域中的程序集的位置信息。
% \item 向代码授予的权限可以由代码运行所在的应用程序域来控制
% \end{itemize}

\section{.NET 框架类库}
\begin{frame}
\frametitle{.NET 框架类库}

\begin{block}{\textit{Framework Class Library, FCL}}
  \CJKindent Microsoft .NET 框架提供了功能丰富的类库，这些类库 ~.NET 框架应用程序的基础。这些类库的应
  用十分广泛，从基本的输入输出，文本处理，到数据库应用、 ~Web 应用等一应俱全。
\end{block}

\begin{itemize}
\item .NET 框架类库是构建 ~.NET 应用程序的基础
\item 通过类库可以看到 ~.NET 提供的各种服务
\item 类库十分庞大，学习曲线较陡
\end{itemize}

% 学习 ~.NET 开发的过程，基本上也是学习 ~.NET FCL 的过程
\end{frame}

\begin{frame}
\frametitle{命名空间的结构}

  \begin{itemize}
  \item 类库是通过{\color<handout:0>{red!60!black}命名空间} (\textit{namespace})构成的树形结构
  \item 命名空间 ~\texttt{System} 是树形结构的根
  \item 命名空间下可以有{\color<handout:0>{red!60!black}子命名空间}或{\color<handout:0>{red!60!black}类}
  \item 用``\textbf{\texttt{.}}''连接，构成命名空间或类库的完整名字 \\ 如 ~\texttt{System.Data.DataSet}
  \end{itemize}

\begin{figure}[h] \label<1| handout:1>{fig:fcl-namespaces}
\centering \input{pgf-dn/fcl-namespaces}
\end{figure}

\end{frame}

\begin{frame}
\frametitle{System 命名空间}

\CJKindent \texttt{\textbf{System}} 是整个类库的根，除了容纳大量的子空间之外，还有很多基本的对象和类型

\begin{itemize}
\item CTS 定义的基本数据类型
  \begin{itemize}
  \item 值类型，如 ~\texttt{Byte}, \texttt{Int16}, \texttt{Int32}, \texttt{Char} 等等
  \item 引用类型，如 ~\texttt{Array}, \texttt{Delegate} 等等
  \item 所有对象的基类 ~\texttt{System.Object}
  \end{itemize}
\item \texttt{\textbf{System.Console}} 类，提供控制台（字符界面）的输入输出功能，如 ~\texttt{WriteLine()},
  \texttt{ReadLine()}等
\item \texttt{\textbf{System.Math}} 类，各种数学函数运算，如 ~\texttt{Sqrt()}, \texttt{Sin()}, \texttt{Ceiling()}, \texttt{Log()}等
\item \texttt{\textbf{System.Enviroment}} 类，用于提供当前运行环境信息，如操作系统、当前目录、内存使用量等
\item \texttt{\textbf{System.Random}} 类，用于产生随机数

\end{itemize}
  
\end{frame}

\begin{frame}
\frametitle{常用的类库简介}
  \begin{itemize}
  \CJKindent
  \item \texttt{\textbf{System.IO}} --- 文件或目录的访问    \smallskip

     \small 基本的输入输出，文件、目录以及内存数据流的访问。
    \smallskip

  \item \texttt{\textbf{System.Net}} --- 网络数据的访问    \smallskip

     \small 使用各种网络协议 ~HTTP, FTP, Mail, 基本的 ~Socket 等进行网络数据通信，简化了
    网络应用程序的开发。
    \smallskip

  \item \texttt{\textbf{System.Text}} --- 文本处理    \smallskip

     \small 提供不同编码文本之间的转换功能，文本处理功能，正则表达式搜索及匹配文本等等。
    \smallskip

  \item \texttt{\textbf{System.Data}} --- ADO.NET 的基础    \smallskip

     \small 实现了 ~ADO.NET 的类库，用于访问各种数据源，如
    \begin{itemize}
    \item \texttt{System.Data.SqlClient}
    \item \texttt{System.Data.OracleClient}
    \item \texttt{System.Data.ODBC}
    \end{itemize}
    \smallskip

    % System.Threading, System.Web, System.Windows, System.XML

  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{.NET 编程语言}
\framesubtitle{Microsoft 提供编程语言}
%超过20种，同样的开发界面、调试方式、同样的类库

\begin{itemize}
  \CJKindent
\item Visual C\# .NET  \par
  \smallskip \small .NET 平台首推的开发语言
\item Visual Basic .NET \par
  \smallskip \small 方便 ~VB 程序员进行 ~.NET 开发
\item Visual C++ .NET (Managed C++) \par
  \smallskip \small 同时利用 ~C++ 和 .NET 平台(类库)
\item Visual J\# .NET (Java) \par
  \smallskip \small 方便 ~Java 程序员，移植现有 ~Java 项目到 ~.NET 平台
\item JScript .NET \par
  \smallskip \small 使用 ~JScript 利用 ~.NET 平台(类库)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{.NET 编程语言}
\framesubtitle{其他可以在 ~.NET 平台编译的语言 }
%超过20种，同样的开发界面、调试方式、同样的类库
\begin{columns}[t]
  \column{.28\textwidth}
  \begin{itemize}
  \item Fortran
  \item Python
  \item Perl
  \item Scheme
  \item Haskell
  \item Smalltalk
  \end{itemize}
  \column{.28\textwidth}
  \begin{itemize}
  \item F\#
  \item COBOL
  \item Mercury
  \item Mondrian
  \item Oberon
  \item Eiffel\#
  \end{itemize}
  \column{.44\textwidth}
  \begin{itemize}
  \item Component Pascal
  \item RPG
  \item Delta Forth
  \item Standard ML
  \item TMT Pascal 
  \item $\ldots$
  \end{itemize}
\end{columns}
\end{frame}



\section{.NET 开发工具}
\begin{frame}
\frametitle{.NET 开发工具}

\begin{exampleblock}{\textit{Microsoft .NET Framework Redistributable}}
  \CJKindent .NET 框架可再发行组件包，包括 ~.NET Framework 应用程序运行所需的库及相关文件。
\end{exampleblock}

\begin{exampleblock}{\textit{Software Development Kit (SDK)}}
  \CJKindent .NET 框架开发工具包，包括了编写、生成、测试和部署 .NET Framework 应用程序所需的工具、文档和示例。
\end{exampleblock}

\begin{block}{\textit{Visual Studio .NET}}
  \CJKindent 
\end{block}

\end{frame}

\begin{frame}[t]
\frametitle{SDK 中的工具 --- \textit{csc}}
\begin{exampleblock}{C\# 编译器 ~csc.exe}
  \begin{tabular}{l|l}
    \hline
    \multicolumn{1}{c|}{Option} & \multicolumn{1}{c}{Description}\\\hline
    \texttt{/help} & 列出所有命令行选项 \\
    \texttt{/define:\textsl{symbol}}  & 定义编译预处理符号 \\
    \texttt{/doc:\textsl{name}} & 从源码 ~XML 注释中生成 ~XML 文档 \\
    \texttt{/out:\textsl{name}} & 输出文件名 \\
    \texttt{/target:\textsl{target}} & 输出文件格式 ~{\small exe/winexe/library/module} \\
    \hline
    \end{tabular}
\end{exampleblock}
\setbeamertemplate{blocks}[rounded][shadow=true]

\begin{alertblock}{}
  \texttt{csc /target:exe     /out:Hello.exe MyHello.cs}\\
  \texttt{csc /target:library /out:Hello.dll MyHello.cs}
\end{alertblock}

\begin{alertblock}{}
   \texttt{csc /target:module A.cs}\\
  \texttt{csc /out:Final.dll /addmodule:A.netmodule \wraphere \hskip.12\textwidth /target:library B.cs}
\end{alertblock}
\end{frame}

\begin{frame}[fragile,t]
\frametitle{SDK 中的工具 --- ildasm}
\begin{exampleblock}{MSIL 的反编译工具 ~ildasm.exe}
  \uncover<1-| handout:1>{  \texttt{csc /target:exe     /out:Hello.exe MyHello.cs}\\}
  \uncover<2-| handout:1>{  \texttt{ildasm Hello.exe}\\
}  
\end{exampleblock}
\begin{onlyenv}<1| handout:0>
\begin{lstlisting}
using System;
class Hello
{
  public static void Main ()
  {
    Console.WriteLine("Hello World!");
  }
}
\end{lstlisting}
\end{onlyenv}

  \includegraphics[scale=.5]<2| handout:1>{ildasm1.png}%
  \rlap{\includegraphics[scale=.5]<3| handout:0>{ildasm2.png}}%

\end{frame}

\begin{frame}
\frametitle{SDK 中的工具 --- others}

\begin{itemize}
\item vbc.exe --- VB.NET 编译工具
\item cl.exe  --- C++ 编译工具
\item al.exe  --- 程序集生成工具
\item ilasm.exe --- MSIL 的编译工具
\item dumpbin.exe --- PE 文件查看工具
\item ngen.exe --- 本地镜像生成工具
\item xsd.exe --- XML 模式定义工具
\item sn.exe --- 增强名工具
\end{itemize}
  
\end{frame}
% 传统的Windows开发 和 .NET 中 Windows 开发


% Local Variables: 
% mode: LaTeX
% TeX-master: "lesson-01.tex"
% TeX-header-end: "% End-Of-Header$"
% TeX-trailer-start: "% Start-Of-Trailer$"
% fill-column: 100
% coding: gb2312-dos
% End:
