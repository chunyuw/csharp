%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn>
\part{.NET}

\section{.NET 平台}
\begin{frame} \frametitle{什么是 ~Microsoft .NET} 

  \CJKindent .NET 是 ~Microsoft 的用以创建 ~XML Web 服务平台，该平台将信息、设
  备和人以一种统一的、个性化的方式联系起来。

  借助于 ~.NET 平台，可以创建和使用基于 ~XML 的应用程序、进程和 ~Web 站点以及服
  务，它们之间可以按设计、在任何平台或智能设备上共享和组合信息与功能，以向单位
  和个人提供定制好的解决方案。
  
  % Microsoft .NET 扩展了通过任何设备随时随地操作数据和进行通讯的能力。.NET 使
  % 用分布式计算模型并基于开放标准（如 XML）将 PC 与其他智能设备连接在一起。

  % XML 是 Internet 上数据交换的通用语言。它提供了一个广泛包容的、开放标准的技
  % 术，用于数据交换和转换，克服了应用程序和服务互操作性和集成面临的障碍。
  
    \begin{itemize}
    \item 一组用于创建互联网操作系统的构建块，其中包括 ~Passport .NET 以及用于文
      件存储的服务、用户首选项管理、日历管理以及众多的其它任务
    \item 构建和管理新一代服务的基本结构和工具，包括 ~Visual Studio .NET, .NET
      企业服务器、 .NET 框架和 ~Windows .NET
    \item 能够启用新型智能互联网设备的 ~.NET 设备软件
    \item 功能丰富而自然的用户界面，个人信息管理和控制，一系列全新的 ~.NET 用户体验
    \end{itemize}
    % http://www.microsoft.com/china/press/2000/06/0627a.mspx

  % \begin{itemize}
  % \item Microsoft .NET Framework
  % \item Microsoft Visual Studio
  % \end{itemize}

\end{frame}

\begin{frame} \frametitle{Microsoft .NET 平台的设计目标}
  \CJKindent

  Microsoft .NET 平台利用以互联网为基础的计算和通讯激增的特点，通过先进的软件，
  利用网络协议和格式，协调众多的智能设备与网站，从而提供更简单、更为个性化、更
  有效的互联网服务。.NET 为一个集成环境，可以在 ~Internet，Windows 桌面以及移动
  设备上进行无缝地开发和运行应用程序。

  \begin{itemize}
  \item 提供一个覆盖整个应用范围的、一致的面向对象环境
  \item 简化代码的发布/安装过程，最小化版本冲突问题
    % DLL Hell
  \item 基于公认的标准，提供一个可移植的环境
    % C\# 和 .NET CLI 已经得到了 ECMA (欧洲计算机制造协会) 的标准化.
  \item 提供一个可管理的环境，保证程序的安全执行
  \end{itemize}
  % 兼容 Win32 API 和 COM

\end{frame}

\begin{frame}[t] \frametitle{Microsoft .NET 相关技术标准}
  \begin{itemize}
  \item<1-> XML\only<1>{, \textit{eXtensible Markup Language}} \only<2->{--- 基于 ~Web 的结构化数据的通用格式}
    \medskip

    \only<1>{\CJKindent \small XML 是一组设计文本数据格式的规则，所产生的文件意
      义明确并且独立于平台，方便生成和（被计算机）读取。当前，如果一个 ~Web 应用
      程序要从另一个应用程序那里检索数据，它必须借助“屏幕搜索”- 捕获带有它所
      需数据的屏幕图片，并试图弄清如何把图片解释回数据。这样做效率非常低，并且
      容易产生错误。XML 为 ~XML Web 服务提供了一种格式，使其能够交换实际数据而不
      是包含数据的图片。}

  \item<2-> SOAP\only<2>{, \textit{Simple Object Access Protocol}} \only<3->{--- 简单对象访问协议}
    \medskip

    \only<2>{\CJKindent \small 它使应用程序可以通过一种标准的，松耦合的方式相互
      调用，这使生成在 ~Internet 上分发的应用程序成为可能。

      如果将 ~XML Web 服务之间的交互想象成电话通话，则 ~XML 描述了应用程序在
      它们的对话中相互所说的内容，SOAP 则描述了它们在电话里是如何呼叫对方的。}

    % 与 XML 一样，SOAP 是 W3C 标准过程的一部分，是由 Microsoft 和包括 IBM 在内
    % 的很多其他公司联合建议的。 XML 和 SOAP 实际上已经得到了业内主要软件供应商
    % 的公开认可，包括 Microsoft, IBM, HP, Sun 和 Oracle。

  \item<3-> UDDI\only<3>{, \textit{Universal Description, Discovery and Integration}} \only<4->{--- 统一描述、发现和集成}
    \medskip

    \only<3>{\CJKindent \small 如果 ~XML 是对话，SOAP 描述呼叫他人的规则，那
      么 ~UDDI 就是电话号码簿。UDDI 提供了一个 ~XML Web 服务的目录，便于查找提
      供 ~XML Web 服务的企业。UDDI 现在是一个有超过 200 家公司参与的群体过
      程，UDDI 群体的目的是在未来某个时间将其提交到一个正式的标准组织。}

  \item<4-> WSDL\only<4>{, \textit{Web Services Description Language}} \only<5->{--- Web 服务描述语言}
    \medskip

    \only<4>{\CJKindent \small WSDL 提供了一个标准方法，用以描述一个特定 ~XML
      Web 服务提供何种函数，以及调用这些函数时必须传递哪些参数。与 ~XML, SOAP,
      UDDI 一样， WSDL 也已经提交给 ~W3C 进行标准化。}

  \item<5-> C\# 和 ~CLI\only<5>{, \textit{Common Language Infrastructure}} \only<6->{--- .NET 框架的一部分}
    \medskip

    \only<5>{\CJKindent \small Microsoft 为 ~XML Web 服务家族创建的一种编程语
      言 ~C\#。并且已经提交给 ~ECMA 进行标准化。 Microsoft 还向 ~ECMA 提交
      了 ~Microsoft .NET 框架的一个子集，叫做公共语言基础结构 (CLI)。这将使其他
      供应商能够在各种平台上实现 ~CLI，以便用 ~.NET 框架提供的基本体系结构模型所
      写的软件可以在各种平台上用各种工具来创建。}

  \end{itemize}
  \medskip

  \only<6>{\CJKindent Microsoft 致力于为支持 ~.NET 的主要技术制订标准。使软件能
    够交互操作和交换数据的技术标准化，将使涉及多种操作平台的解决方案成为可能，
    从而使最终用户受益。}

\end{frame}

% 对于开发人员而言，丰富的类库，方便的集成，以及发布、部署和维护方便性显得尤为
% 重要

\begin{frame} \frametitle{公共语言基础结构}
  \framesubtitle{实现 ~.NET 平台的基础}
  \begin{block}{\textit{Common Language Infrastructure(CLI)}}
    \CJKindent CLI 定义了一个与平台无关的虚拟代码执行环境。包括公共中间语言和公
    共类型系统，相应的语法、语义和部分 ~.NET 框架类库。
  \end{block}
  \begin{itemize}
  \item<2-> CLI 中没有指定操作系统，可以在任何的系统或设备上实现
  \item<3-> 其他公司也可以根据 ~CLI 标准实现相关技术
    \begin{itemize}
    \item Microsoft .NET Framework -- 微软公司自己的实现
    \end{itemize}
  \item<4-> 目前已有的开源 ~.NET 平台
    \begin{itemize}
    \item Mono Project --- http://www.mono-project.com
    \item DotGNU Project --- http://www.dotgnu.org
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[t] \frametitle{Web 服务}
  \begin{block}{\textit{Web Services}}
    {\CJKindent Web Services 是可远程访问的应用程序组件，并且响应以 ~HTTP 为主访
      问请求，提供基于文本的信息服务。}
  \end{block}
  \begin{itemize}
  \item 提供了信息发布的标准方式，方便应用程序访问
  \item 信息不再是网页或文件，以根据需要各取所需
  \item 消除了使用不同组件模型、操作系统之间存在的差异
  \item 方便创建基于 ~Web 服务的分布式应用程序
  \end{itemize}
\end{frame}

\begin{frame}[fragile,t] \frametitle{Web 服务示例}

  \begin{itemize}
  \item http://www.webservicex.net/globalweather.asmx
  \item \only<1>{通过 ~SOAP 的访问} \only<2>{返回的结果}
  \end{itemize}

  \begin{onlyenv}<1>
\begin{lstlisting}[language=XML, showstringspaces=false]
POST /globalweather.asmx HTTP/1.1
Host: www.webservicex.net
Content-Type: text/xml; charset=utf-8
Content-Length: length
SOAPAction: "http://www.webserviceX.NET/GetWeather"

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi= ... >
 <soap:Body>
  <GetWeather xmlns="http://www.webserviceX.NET">
   <CityName>Harbin</CityName>
   <CountryName>China</CountryName>
  </GetWeather>
 </soap:Body>
</soap:Envelope>
\end{lstlisting}
  \end{onlyenv}

  \begin{onlyenv}<2>
\begin{lstlisting}[language=XML, showstringspaces=false]
HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi= ... >
 <soap:Body>
  <GetWeatherResponse 
           xmlns="http://www.webserviceX.NET">
   <GetWeatherResult>string</GetWeatherResult>
  </GetWeatherResponse>
 </soap:Body>
</soap:Envelope>
\end{lstlisting}
  \end{onlyenv}
\end{frame}

\section{ .NET 框架简介}

\begin{frame} \frametitle{Microsoft .NET Framework}
  \framesubtitle{功能丰富的开发平台}
  \begin{itemize}
  \item \large 互联网、分布式应用程序、Windows 应用程序
  \item \large 创建与运行 ~Windows 应用程序的基础
  \item \large 创建与使用 ~Web Services 的工具
  \item \large 便携设备的开发和运行的环境
  \end{itemize}
\end{frame}

\begin{frame}[t]\frametitle{Microsoft .NET Framework}
  \framesubtitle{功能丰富的开发平台}
  \begin{exampleblock}{提供了丰富的类库}
    \begin{columns}
      \column{4cm}
      \begin{itemize}
      \item ASP.NET
      \item Windows Forms
      \item Enterprise Services
      \end{itemize}
      \column{4cm}
      \begin{itemize}
      \item ADO.NET
      \item Web Services
      \item ...
      \end{itemize}
    \end{columns}
  \end{exampleblock}
  \begin{onlyenv}<2>
    \begin{itemize}
    \item 充分利用代码复用，简化了应用程序的开发
    \item 类库提供开发所需的各种基本功能，可以支持各种类型的应用程序
    \item 类库屏蔽了底层细节，统一了编程模式，易于使用
    \item 容易维护、部署等
    \end{itemize}
  \end{onlyenv}
  \begin{onlyenv}<3>
    \begin{block}{完整的安全解决方案}
      \begin{itemize}
      \item 基于证据的安全规则，确保组件的来源可靠
      \item 细致的权限设置，可以为组件设置不同权限
        \begin{itemize}
        \item 访问注册表
        \item 文件读取
        \item 访问网络
        \end{itemize}
      \end{itemize}
    \end{block}
  \end{onlyenv}
\end{frame}

\begin{frame} \frametitle{.NET 框架的组成}
  \begin{itemize}
  \item 公共语言运行环境 --- \textit{Common Language Runtime}
  \item .NET 框架类库 --- \textit{Framework Class Library}
    % 组成的内容 (文字)
  \end{itemize}

  \input{pgf-dn/dn-framework}   % .NET 框架的层次图 (图)
\end{frame}

% 多种语言之间的交互

\section{CLR 公共语言运行环境}
\begin{frame} \frametitle{公共语言运行环境}
  \begin{block}{\textit{Common Language Runtime(CLR)}}
    \CJKindent 全部 ~.NET Framework 的基础，为 ~.NET 程序提供了一个虚拟机环境，
    以支持进程的创建和执行，托管代码和非托管代码的交互，为进程提供必要的服务。
  \end{block}
  % \input{pgf-dn/clr-compile-exec}
  \begin{itemize}
  \item<2-| handout:1> CLR 要管理\alert<2>{托管代码}的整个运行周期：查找代码、编译、加载相
    关的类、运行、自动内存管理
  \item<3-| handout:1> 提供多种语言都支持的\alert<3>{公共类型系统}，定义如何声
    明和管理 ~CLR 中的类型
  \item<4-| handout:1> 支持跨语言集成，允许不同语言生成的代码能够无缝地交互
  \item<5-| handout:1> 管理类型系统的安全，管理组件的安全
  \item<6-| handout:1> 负责访问其他系统资源，提供 ~Win32 API, COM 等访问接口
  \end{itemize}
  % \begin{itemize}
  % \item 提供通用类型系统 (CTS)\\
  %   值类型：整数、浮点数、结构体等\\
  %   引用类型：类对象、委托、接口等
  % \item 为托管代码执行提供服务\\
  %   智能内存管理，元数据管理，受管库的加载与分析，处理异常，代码互操作
  % \item 访问系统资源\\
  %   Win32 API 或 COM 等
  % \end{itemize}

\end{frame}

\begin{frame} \frametitle{托管代码和托管数据'}
  什么是托管代码和托管数据？托管代码是编写为支持公共语言运行时服务的代码（请参
  阅“什么是公共语言运行时？”）。为了支持这些服务，代码必须向运行时提供最小级
  别的信息（元数据）。默认情况下，所有 C\#、Visual Basic.NET 和 JScript.NET 代码
  都是托管代码。Visual Studio.NET C++ 代码在默认情况下不是托管代码，但通过指定
  命令行开关 (/CLR)，编译器也可以生成托管代码。

  与托管代码密切相关的是托管数据。托管数据是由公共语言运行时的垃圾回收器进行分
  配和释放的数据。默认情况下，C\#、Visual Basic 和 JScript.NET 数据是托管数据。
  不过，通过使用特殊的关键字，C\# 数据可以被标记为非托管数据。Visual Studio.NET
  C++ 数据在默认情况下是非托管数据（即使在使用 /CLR 开关时），但是在使用 C++ 的
%  托管扩展时，可以使用“__gc”关键字将类标记为托管类。就象该名称所显示的那样，
  它表示类实例的内存由垃圾回收器管理。另外，该类也完全成为 .NET 框架的成员，同
  时具备它所带来的好处和限制。好处的一个例子是：它可以与其他语言编写的类正确地
  进行互操作（如托管的 C++ 类可以从 Visual Basic 类继承）；限制的一个例子是：托
  管类只能从一个基类继承。
\end{frame}

\begin{frame} \frametitle{CLR 虚拟机}
http://msdn2.microsoft.com/en-us/library/ddk909ch.aspx
  \begin{figure}[h]
    \centering
    \input{pgf-dn/clr-compile-exec}
  \end{figure}
\end{frame}


\begin{frame} \frametitle{公共类型系统}
  \begin{block}{\textit{Common Type System(CTS)}}
    \CJKindent CTS 是一组预定义的类型和这些类型行为的规范，描述了如何声明和创建
    定制类型，如何管理这些类型实例的生命周期，以及怎样才能得到 ~CLR 的支持。
  \end{block}
  \begin{itemize}
  \item 定义了声明、使用和管理定制或预定义类型的标准化框架
  \item 使不同的编程语言之间的能够集成
  \item 遵循 ~CTS 能够保障类型的安全和性能的优化
  \item 遵循 ~CTS 的语言不一定支持 ~CTS 中定义的全部类型
  \end{itemize}
\end{frame}

\begin{frame}[c] \frametitle{CTS的类型结构}
  % 所有的类型都派生自Objects类型，而所有的值类型都派生自ValueTypes类型。
  \input{pgf-dn/cts-typesystem}
\end{frame}


\begin{frame} \frametitle{值类型和引用类型}
  值类型和引用类型的区别：
http://msdn2.microsoft.com/en-us/library/2hf02550.aspx
  \begin{figure}[h]
    \centering
    \input{pgf-dn/cts-v-r-types}
  \end{figure}

  % 托管代码执行过程中，变量可以在托管栈或托管堆中分配。
  % 当方法被调用时，局部变量或方法创建的值类型变量都在栈中分配，当方法运行结束时都自动的释放；           
  % 而在堆中分配的变量，并不自动释放，而是通过“垃圾处理”来由CLR管理并释放。

  % 值类型的变量在栈中分配，而引用类型的变量在栈中只有一个引用，指向在堆中实际内存

\end{frame}

\begin{frame} \frametitle{公共语言规范}
  \begin{block}{\textit{Common Language Specification(CLS)}}
    语言互操作的最终规范，定义了遵循 ~CLR 的编译器必须包含的最小特性集，保证语
    言之间的通信。% CTS 的一个子集。
  \end{block}

  \begin{exampleblock}{部分 ~CLS 特性和规则}
    %\rowcolors{1}{RoyalBlue!20}{RoyalBlue!5}
    \begin{tabular}{l|l}
      \hline
      \multicolumn{1}{c|}{\hei特\ \ 性} & \multicolumn{1}{c}{\hei 规\ \ 则}\\\hline
      可见性       & 定义类型的程序集之外有效 \\
      字符和大小写 & 变量除了大小写不同之外，还需要有其他区别 \\
      基本类型     & Byte, Int, Single, Double, Boolean 等 \\
      构造函数调用 & 访问实例数据前，必须调用基类的构造函数 \\
      数组边界     & 数组的各个维下界必须为 ~0 \\
      枚举         & 基类型必须是 ~Byte, Int16, Int32 或 ~Int64 \\
      方法签名     & 签名中返回值和参数的类型必须遵循 ~CLS \\
    \end{tabular}
  \end{exampleblock}

\end{frame}

%\subsection*{托管代码的编译}
\begin{frame}<0> \frametitle{CLR 中程序的运行}
  \begin{itemize}
  \item CLR 定义了一种基于栈的虚拟机
  \item CLR 上执行的代码是 ~CIL 编写的托管代码
  \item CIL 通过 ~JIT 实时的编译为本地代码
  \item CLR 是负责托管代码执行的虚拟运行环境
  \item MSIL 是 ~CIL 的一种实现
  \end{itemize}
\end{frame}

\begin{frame}[c] \frametitle{托管代码的编译}
  
  \begin{itemize}
  \item 托管代码编译后生成 ~MSIL 和元数据
    % {\footnotesize MSIL和元数据都存储在 ~Windows PE文件中，存在形式可以是 ~DLL 或 ~EXE。}
  \item MSIL 和元数据都保存在 ~DLL 或 ~EXE 中
    % {\footnotesize MSIL相当于 ~CLR的汇编语言，而且直接支持 ~CTS 中的各种类型和比较
    %   高级的操作，比如创建对象、类型之间的转换等。}
  \item 元数据描述源代码中定义类型的详细信息
    % {\footnotesize 类的名字、可见性、基类，该类实现的接口、方法、属性和时间等等。}
  \end{itemize}

  \begin{figure}[h]
    \centering
    \input{pgf-dn/clr-compile}
  \end{figure}

\end{frame}

\begin{frame} \frametitle{Microsoft 中间语言}
%什么是 Microsoft 中间语言 (MSIL)？
MSIL 是与 CPU 无关的指令集。.NET 框架程序被编译成 MSIL。它包含加载、存储、初始化和调用对象方法的指令。

与元数据和公共类型系统结合，MSIL 允许真正的跨语言集成。

MSIL 在执行前被转换为机器代码，而不是一边解释一边执行。
\end{frame}

%\subsection*{CLR的执行模型}
% CIL

%\subsection*{托管代码的执行}
\begin{frame} \frametitle{托管代码的执行}
  \framesubtitle{如何寻找并加载程序集}
  \begin{itemize}
  \item 只有在需要的时候加载
    % 如果依赖程序集没有调用，不会被加载；
    % 程序集甚至不需在目标机器上

  \item CLR通过特定的规则寻找需要的程序集
    % 
    \begin{enumerate}
    \item CLR检查是否已经被加载，如果已经加载，结束搜索
    \item 在 ~Global Assembly Cache(GAC)中搜索
    \item 在程序代码中指定的位置搜索
    \item 如果代码没有指定，在 ~Application base查找，可能是目录或 ~URL
    \item 根据 ~.NET 的配置，在其他目录查找
    \item 都未找到，报告错误，结束
    \end{enumerate}

  \item 检查 ~Strong name(如果有)，加载并使用
  \end{itemize}
\end{frame}

\begin{frame} \frametitle{托管代码的执行}
  \framesubtitle{编译 ~MSIL}

\end{frame}

\begin{frame} \frametitle{托管代码的实时编译}
  \only<2->{\input{pgf-dn/clr-execute}}
\end{frame}

% 程序集
% 什么是程序集？

% 程序集是 .NET 框架应用程序的主要构造块。它是作为一个单一实现单元（包含一个或多
% 个文件）来创建、标识和部署的功能集合。所有的托管类型和资源都可以被标记为仅在其
% 实现单元内访问，或者标记为可由该单元以外的代码来访问。

% 程序集通过清单来进行自我说明。清单是每个程序集的不可或缺的组成部分。清单：

% 建立程序集标识（以文本名称的格式）、版本、类别和数字签名（如果要在应用程序之间
% 共享该程序集）。

% 定义组成程序集实现的文件（通过名称和文件散列）。

% 指定组成程序集的类型和资源，包括哪些是从程序集中导出的。

% 逐条记录编译时对其他程序集的依存。

% 指定程序集正确运行所需要的权限的集合。

% 此信息在运行时用于解析引用、强制版本绑定策略以及验证所加载的程序集的完整性。因
% 为每一类型都被加载到程序集的上下文中，所以运行时可以确定并定位任何正在运行的对
% 象的程序集。程序集也是应用了代码访问安全权限的单元。在确定授予其所包含的代码哪
% 些权限时，每个程序集的标识证据都被认为是独立的。

\begin{frame} \frametitle{托管代码的组织}
  \begin{block}{程序集 --- \textit{Assembly}}
    \CJKindent \small .NET 框架应用程序中，由一个或一组文件构成的，单一功能的
    逻辑单元。程序集是组件复用，实施安全策略的最小单位。
  \end{block}
  \begin{itemize}
  \item 程序集可以有一个或多个文件，如 ~DLL, EXE 或资源文件等
  \item 程序集都有一个{\color{red!65!black}清单}(\textit{manifest}{})
  \item 清单描述程序集的内容信息
    \begin{enumerate}
    \item 程序集的名字
    \item 版本号，形如 ~major.minor.build.revision
    \item 支持的语言
    \item 程序集其他文件列表
    \item 所依赖的其他程序集及版本号
    \end{enumerate}
  \end{itemize}
\end{frame}

% 什么是专用程序集和共享程序集？

% 专用程序集仅由单一应用程序使用，并且存储在该应用程序的安装目录中（或其子目录
% 中）。共享程序集是可被多个应用程序引用的程序集。要共享一个程序集，该程序集必
% 须明确为这个目的而创建，这可以通过给其指定加密的增强型名称（用作共享名称）来
% 实现。相反，专用程序集名称只要求在使用它的应用程序中是唯一的。

% 通过区分专用和共享程序集，我们介绍明确决定共享的要点。只需简单地将专用程序集
% 部署在应用程序目录中，即可确保应用程序只在创建和部署它的那部分中运行。对专用
% 程序集的引用只在专用应用程序目录内部进行解析。

% 选择创建和使用共享程序集可以有多种原因，例如表达版本策略的能力。共享程序集具
% 有加密的增强型名称，这项事实意味着只有程序集的作者才拥有密钥来生成程序集的新
% 版本。因此，如果您做出策略声明，希望接受程序集的新版本，则您可以确信版本更新
% 将由作者来控制和验证。否则，您就不会接受它们。

% 对于在本地安装的应用程序，共享程序集通常被明确安装在全局程序集缓存中（程序集
% 的本地缓存由 .NET 框架维护）。.NET 框架的版本管理特性的关键在于下载的代码不会
% 影响本地安装的应用程序的执行。下载的代码被放在一个特殊的下载缓存中，即使某些
% 下载组件被编译为共享程序集，也不能在机器上全局使用这些代码。

% 与 .NET 框架一起发布的类都被编译为共享程序集。


\begin{frame} \frametitle{程序集的功能}
  \begin{itemize}
  \item 程序集定义了类型的有效范围
    % CLR 通过程序集查找类的定义
  \item 程序集不需要注册表项
    % CLR 通过一种算法查找程序集的位置 
  \item 安装 ~.NET 应用程序，只拷贝它的程序集即可
    % 安装与卸载 ~.NET 模块不需要修改系统注册表，只需 ~copy or delete

  \item 程序集可以有一个 ~Strong name
    \begin{itemize}
    \item 除了三个必须的成员之外，还要有数字签名和相应的公钥
    \item 通过数字签名，可以确保程序集的唯一性，增加安全性
    \end{itemize}

  \item 允许不同版本的程序集并存，可有效避免 ~DLL Hell
    % 因为程序集需要指定版本号，而程序集的依赖也如此
  \end{itemize}
\end{frame}


\section{.NET 框架类库(FCL)}
% 名子空间
% 
\begin{frame}
  Microsoft .NET 框架提供了功能丰富的类库，这些类库 ~.NET 框架应用程序的基础。这
  些类库的应用十分广泛，从基本的输入输出，文本处理，到数据库应用、 ~Web应用一应俱
  全。
% 学习 ~.NET 开发的过程，基本上也是学习 ~.NET FCL 的过程
  \begin{itemize}
  \item 类库结构是一个命名空间(namespace)的树形结构
  \item 命名空间 ~System 是树形结构的根
  \item 命名空间下可以有子命名空间或类(class)
  \item 命名空间或类之间通过``.''连接
  \end{itemize}
\end{frame}

\begin{frame} \frametitle{命名空间的结构}
\input{pgf-dn/fcl-namespaces}
  % 图
\end{frame}

\begin{frame} \frametitle{基本的类库简介}
  \begin{itemize}
  \item System.IO -- 文件或目录的访问

    基本的输入输出，文件、目录以及内存数据流的访问。

  \item System.Net -- 网络数据的访问

    使用各种网络协议 ~HTTP, FTP, Mail, 基本的 ~Socket 等进行网络数据通信，简化了
    网络应用程序的开发。

  \item System.Text -- 文本处理

    提供不同编码文本之间的转换功能，文本处理功能，正则表达式搜索及匹配文本等等。

  \item System.Data -- ADO.NET 的基础

    实现了 ~ADO.NET 的类库，用于访问各种数据源，比如 ~System.Data.SqlClient,
    System.Data.OracleClient, System.Data.ODBC等等。

    % System.Threading, System.Web, System.Windows, System.XML

  \end{itemize}
\end{frame}

\begin{frame} \frametitle{.NET 编程语言}
%超过20种，同样的开发界面、调试方式、同样的类库
\end{frame}


%\subsection*{受管开发环境}

%\subsection*{垃圾回收}

\section{.NET 语言}



% Local Variables: 
% mode: LaTeX
% TeX-master: "lesson-01.tex"
% TeX-header-end: "% End-Of-Header$"
% TeX-trailer-start: "% Start-Of-Trailer$"
% coding: gb2312-dos
% End:
