%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn>

\section{.NET 平台}
\begin{frame}
\frametitle{什么是 ~Microsoft .NET} 

  \CJKindent .NET 是 ~Microsoft 的用以创建 ~XML Web 服务平台，该平台将信息、设
  备和人以一种统一的、个性化的方式联系起来。

  \smallskip

  借助于 ~.NET 平台，可以创建和使用基于 ~XML 的应用程序、进程和 ~Web 站点以及服
  务，它们之间可以按设计、在任何平台或智能设备上共享和组合信息与功能，以向单位
  和个人提供定制好的解决方案。
  
  % Microsoft .NET 扩展了通过任何设备随时随地操作数据和进行通讯的能力。.NET 使
  % 用分布式计算模型并基于开放标准（如 XML）将 PC 与其他智能设备连接在一起。

  % XML 是 Internet 上数据交换的通用语言。它提供了一个广泛包容的、开放标准的技
  % 术，用于数据交换和转换，克服了应用程序和服务互操作性和集成面临的障碍。
  
  \begin{uncoverenv}<2-| handout:1>
    \begin{itemize}
    \item 一组用于创建互联网操作系统的构建块，其中包括 ~Passport .NET 以及用于
      文件存储的服务、用户首选项管理、日历管理以及众多的其它任务
    \item 构建和管理新一代服务的基本结构和工具，包括 ~Visual Studio .NET, .NET
      企业服务器、 .NET 框架和 ~Windows .NET
    \item 能够启用新型智能互联网设备的 ~.NET 设备软件
    \item 功能丰富而自然的用户界面，个人信息管理和控制，一系列全新的 ~.NET 用户
      体验
    \end{itemize}
  \end{uncoverenv}
    % http://www.microsoft.com/china/press/2000/06/0627a.mspx

  % \begin{itemize}
  % \item Microsoft .NET Framework
  % \item Microsoft Visual Studio
  % \end{itemize}

\end{frame}

\begin{frame}
\frametitle{Microsoft .NET 平台的设计目标}
\CJKindent

Microsoft .NET 平台利用以互联网为基础的计算和通讯激增的特点，通过先进的软件，
利用网络协议和格式，协调众多的智能设备与网站，从而提供更简单、更为个性化、更
有效的互联网服务。.NET 为一个集成环境，可以在 ~Internet，Windows 桌面以及移动
设备上进行无缝地开发和运行应用程序。

  \begin{itemize}
  \item 提供一个覆盖整个应用范围的、一致的面向对象环境
  \item 简化代码的发布/安装过程，最小化版本冲突问题
    % DLL Hell
  \item 基于公认的标准，提供一个可移植的环境
    % C\# 和 .NET CLI 已经得到了 ECMA (欧洲计算机制造协会) 的标准化.
  \item 提供一个可管理的环境，保证程序的安全执行
  \end{itemize}
  % 兼容 Win32 API 和 COM

\end{frame}

\begin{frame}[t]
\frametitle{Microsoft .NET 相关技术标准}
  \begin{itemize}
  \item<1-| handout:1> XML\only<1| handout:0>{, \textit{eXtensible Markup Language}} 
    \only<2-| handout:1>{--- 基于 ~Web 的结构化数据的通用格式}
    \medskip

    \only<1| handout:0>{\CJKindent \small XML 是一组设计文本数据格式的规则，所产生的文件意
      义明确并且独立于平台，方便生成和（被计算机）读取。当前，如果一个 ~Web 应用
      程序要从另一个应用程序那里检索数据，它必须借助“屏幕搜索”- 捕获带有它所
      需数据的屏幕图片，并试图弄清如何把图片解释回数据。这样做效率非常低，并且
      容易产生错误。XML 为 ~XML Web 服务提供了一种格式，使其能够交换实际数据而不
      是包含数据的图片。}

  \item<2-| handout:1> SOAP\only<2| handout:0>{, \textit{Simple Object Access Protocol}}
    \only<3-| handout:1>{--- 简单对象访问协议}
    \medskip

    \only<2| handout:0>{\CJKindent \small 它使应用程序可以通过一种标准的，松耦合的方式相互
      调用，这使生成在 ~Internet 上分发的应用程序成为可能。

      如果将 ~XML Web 服务之间的交互想象成电话通话，则 ~XML 描述了应用程序在
      它们的对话中相互所说的内容，SOAP 则描述了它们在电话里是如何呼叫对方的。}

    % 与 XML 一样，SOAP 是 W3C 标准过程的一部分，是由 Microsoft 和包括 IBM 在内
    % 的很多其他公司联合建议的。 XML 和 SOAP 实际上已经得到了业内主要软件供应商
    % 的公开认可，包括 Microsoft, IBM, HP, Sun 和 Oracle。

  \item<3-| handout:1> UDDI\only<3| handout:0>{, \textit{Universal Description, Discovery and Integration}}
    \only<4-| handout:1>{--- 统一描述、发现和集成}
    \medskip

    \only<3| handout:0>{\CJKindent \small 如果 ~XML 是对话，SOAP 描述呼叫他人的规则，那
      么 ~UDDI 就是电话号码簿。UDDI 提供了一个 ~XML Web 服务的目录，便于查找提
      供 ~XML Web 服务的企业。UDDI 现在是一个有超过 200 家公司参与的群体过
      程，UDDI 群体的目的是在未来某个时间将其提交到一个正式的标准组织。}

  \item<4-| handout:1> WSDL\only<4| handout:0>{, \textit{Web Services Description Language}}
    \only<5-| handout:1>{--- Web 服务描述语言}
    \medskip

    \only<4| handout:0>{\CJKindent \small WSDL 提供了一个标准方法，用以描述一个特定 ~XML
      Web 服务提供何种函数，以及调用这些函数时必须传递哪些参数。与 ~XML, SOAP,
      UDDI 一样， WSDL 也已经提交给 ~W3C 进行标准化。}

  \item<5-| handout:1> C\# 和 ~CLI\only<5| handout:0>{, \textit{Common Language Infrastructure}}
    \only<6-| handout:1>{--- .NET 框架的一部分}
    \medskip

    \only<5| handout:0>{\CJKindent \small Microsoft 为 ~XML Web 服务家族创建的一种编程语
      言 ~C\#。并且已经提交给 ~ECMA 进行标准化。 Microsoft 还向 ~ECMA 提交
      了 ~Microsoft .NET 框架的一个子集，叫做公共语言基础结构 (CLI)。这将使其他
      供应商能够在各种平台上实现 ~CLI，以便用 ~.NET 框架提供的基本体系结构模型所
      写的软件可以在各种平台上用各种工具来创建。}

  \end{itemize}
  \medskip

  \only<6| handout:1>{\CJKindent Microsoft 致力于为支持 ~.NET 的主要技术制订标准。使软件能
    够交互操作和交换数据的技术标准化，将使涉及多种操作平台的解决方案成为可能，
    从而使最终用户受益。}

\end{frame}

% 对于开发人员而言，丰富的类库，方便的集成，以及发布、部署和维护方便性显得尤为
% 重要

\begin{frame}
\frametitle{公共语言基础结构}
  \framesubtitle{实现 ~.NET 平台的基础}
  \begin{block}{\textit{Common Language Infrastructure(CLI)}}
    \CJKindent CLI 定义了一个与平台无关的虚拟代码执行环境。包括公共中间语言和公
    共类型系统，相应的语法、语义和部分 ~.NET 框架类库。
  \end{block}
  \begin{itemize}
  \item<2-| handout:1> CLI 中没有指定操作系统，可以在任何的系统或设备上实现
  \item<3-| handout:1> 其他公司也可以根据 ~CLI 标准实现相关技术
    \begin{itemize}
    \item Microsoft .NET Framework -- 微软公司自己的实现
    \end{itemize}
  \item<4-| handout:1> 目前已有的开源 ~.NET 平台
    \begin{itemize}
    \item Mono Project --- http://www.mono-project.com
    \item DotGNU Project --- http://www.dotgnu.org
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[t]
\frametitle{Web 服务}
  \begin{block}{\textit{Web Services}}
    {\CJKindent Web Services 是可远程访问的应用程序组件，并且响应以 ~HTTP 为主访
      问请求，提供基于文本的信息服务。}
  \end{block}
  \begin{itemize}
  \item 提供了信息发布的标准方式，方便应用程序访问
  \item 信息不再是网页或文件，以根据需要各取所需
  \item 消除了使用不同组件模型、操作系统之间存在的差异
  \item 方便创建基于 ~Web 服务的分布式应用程序
  \end{itemize}
\end{frame}

\begin{frame}[fragile,t]
\frametitle{Web 服务示例}

  \begin{itemize}
  \item http://www.webservicex.net/globalweather.asmx
  \item \only<1| handout:1>{通过 ~SOAP 的访问} \only<2| handout:0>{返回的结果}
  \end{itemize}

  \begin{onlyenv}<1| handout:1>
\begin{lstlisting}[language=XML, showstringspaces=false]
POST /globalweather.asmx HTTP/1.1
Host: www.webservicex.net
Content-Type: text/xml; charset=utf-8
Content-Length: length
SOAPAction: "http://www.webserviceX.NET/GetWeather"

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi= ... >
 <soap:Body>
  <GetWeather xmlns="http://www.webserviceX.NET">
   <CityName>Harbin</CityName>
   <CountryName>China</CountryName>
  </GetWeather>
 </soap:Body>
</soap:Envelope>
\end{lstlisting}
  \end{onlyenv}

  \begin{onlyenv}<2| handout:0>
\begin{lstlisting}[language=XML, showstringspaces=false]
HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: length

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi= ... >
 <soap:Body>
  <GetWeatherResponse 
           xmlns="http://www.webserviceX.NET">
   <GetWeatherResult>string</GetWeatherResult>
  </GetWeatherResponse>
 </soap:Body>
</soap:Envelope>
\end{lstlisting}
  \end{onlyenv}
\end{frame}

\section{ .NET 框架简介}

\begin{frame}
\frametitle{Microsoft .NET Framework}
  \framesubtitle{功能丰富的开发平台}
  \begin{itemize}
  \item \large 互联网、分布式应用程序、Windows 应用程序
  \item \large 创建与运行 ~Windows 应用程序的基础
  \item \large 创建与使用 ~Web Services 的工具
  \item \large 便携设备的开发和运行的环境
  \end{itemize}
\end{frame}

\begin{frame}[t]\frametitle{Microsoft .NET Framework}
  \framesubtitle{功能丰富的开发平台}
  \begin{exampleblock}{提供了丰富的类库}
    \begin{columns}
      \column{4cm}
      \begin{itemize}
      \item ASP.NET
      \item Windows Forms
      \item Enterprise Services
      \end{itemize}
      \column{4cm}
      \begin{itemize}
      \item ADO.NET
      \item Web Services
      \item ...
      \end{itemize}
    \end{columns}
  \end{exampleblock}
  \begin{onlyenv}<2| handout:0>
    \begin{itemize}
    \item 充分利用代码复用，简化了应用程序的开发
    \item 类库提供开发所需的各种基本功能，可以支持各种类型的应用程序
    \item 类库屏蔽了底层细节，统一了编程模式，易于使用
    \item 容易维护、部署等
    \end{itemize}
  \end{onlyenv}
  \begin{onlyenv}<3| handout:1>
    \begin{block}{完整的安全解决方案}
      \begin{itemize}
      \item 基于证据的安全规则，确保组件的来源可靠
      \item 细致的权限设置，可以为组件设置不同权限
        \begin{itemize}
        \item 访问注册表
        \item 文件读取
        \item 访问网络
        \end{itemize}
      \end{itemize}
    \end{block}
  \end{onlyenv}
\end{frame}

\begin{frame}
\frametitle{.NET 框架的组成}
  \begin{itemize}
  \item 公共语言运行时 --- \textit{Common Language Runtime}
  \item .NET 框架类库 --- \textit{Framework Class Library}
    % 组成的内容 (文字)
  \end{itemize}

  \only<1| handout:1>{\label{fig:dn-framework}}
    \centering \input{pgf-dn/dn-framework} % .NET 框架的层次图 (图)

\end{frame}

% 多种语言之间的交互

\section{公共语言运行时}
\begin{frame}
\frametitle{公共语言运行时}
  \begin{block}{\textit{Common Language Runtime(CLR)}}
    \CJKindent 全部 ~.NET Framework 的基础，为 ~.NET 程序提供了一个虚拟机环境，
    以支持进程的创建和执行，托管代码和非托管代码的交互，为进程提供必要的服务。
  \end{block}

  % \begin{figure}[h] \only<1-| handout:1>{\label{fig:clr-compile-exec}}
  %   \centering \input{pgf-dn/clr-compile-exec}
  % \end{figure}

  \begin{itemize}
  \item<2-| handout:1> CLR 要管理\alert<2| handout:0>{托管代码}的整个运行周期：查找代码、编译、加载相
    关的类、运行、自动内存管理
  \item<3-| handout:1> 提供多种语言都支持的\alert<3| handout:0>{公共类型系统}，定义如何声
    明和管理 ~CLR 中的类型
  \item<4-| handout:1> 支持跨语言集成，允许不同语言生成的代码能够无缝地交互
  \item<5-| handout:1> 管理类型系统的安全，管理组件的安全
  \item<6-| handout:1> 负责访问其他系统资源，提供 ~Win32 API, COM 等访问接口
  \end{itemize}

  % \begin{itemize}
  % \item 提供通用类型系统 (CTS)\\
  %   值类型：整数、浮点数、结构体等\\
  %   引用类型：类对象、委托、接口等
  % \item 为托管代码执行提供服务\\
  %   智能内存管理，元数据管理，受管库的加载与分析，处理异常，代码互操作
  % \item 访问系统资源\\
  %   Win32 API 或 COM 等
  % \end{itemize}

\end{frame}

\begin{frame}
\frametitle{托管代码}

\begin{block}{\textit{Managed Code}}
\CJKindent 托管代码是由面向 ~CLR 的编译器生成，支持公共语言运行时服务的代码，为了支持这些服务，代码必须向运行时提供最小级
别的信息，即元数据 (\textit{metadata})。
\end{block}

\begin{itemize}
\item<2-| handout:1> 托管代码的运行受 ~CLR 控制，如内存分配、类型检查、安全验证、垃圾回收等
\item<3-| handout:1> 由公共语言运行时的垃圾回收器进行分配和释放的数据，称为托管数据
\item<4-| handout:1> 默认情况下，所有 ~C\#, Visual Basic.NET 和 ~JScript.NET 代码都是托管代码
\item<5-| handout:1> Visual Studio.NET C++ 默认情况下不是，但通过编译器命令行开关 (\texttt{/CLR})，也可以生成托管代码。
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{CLR 虚拟机}
  \begin{itemize}
  \item<1-| handout:1> CLR 相当于一种虚拟机，独立于操作系统或体系结构
  \item<2-| handout:1> .NET 编译器生成 ~Windows PE (\textit{Portable Executable}) 文件，扩展名通常
    为 ~DLL 或 ~EXE
  \item<3-| handout:1> Windows PE 文件实际内容是面向 ~CLR 的中间语言文件，以及执行所需的 ~CLR 文件头
  \item<4-| handout:1> 当执行时，通过调用 ~JIT (\textit{Just-In-Time}) 编译器，实时编译为本地代码
    (\textit{native code})
  \end{itemize}

  \begin{figure}[h] \only<1| handout:1>{\label{fig:clr-compile-exec}}
    \centering \input{pgf-dn/clr-compile-exec}
  \end{figure}
\end{frame}


\begin{frame}
\frametitle{公共类型系统}

  \begin{block}{\textit{Common Type System(CTS)}}
    \CJKindent CTS 是一组预定义的类型和这些类型行为的规范，描述了如何声明和创建
    定制类型，如何管理这些类型实例的生命周期，以及怎样才能得到 ~CLR 的支持。
  \end{block}

  \begin{uncoverenv}<2-| handout:1>
    \begin{itemize}
    \item 定义了声明、使用和管理定制或预定义类型的标准化框架
    \item 使不同的编程语言之间的能够集成
    \item 遵循 ~CTS 能够保障类型的安全和性能的优化
    \item 遵循 ~CTS 的语言不一定支持 ~CTS 中定义的全部类型
    \end{itemize}
  \end{uncoverenv}
\end{frame}

\begin{frame}[c]
\frametitle{CTS 的类型结构}

  % 所有的类型都派生自Objects类型，而所有的值类型都派生自ValueTypes类型。
\begin{figure}[h]  \only<1| handout:1>{\label{fig:cts-typesystem}}
  \centering  \input{pgf-dn/cts-typesystem}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{值类型和引用类型}
%   值类型和引用类型的区别：
% http://msdn2.microsoft.com/en-us/library/2hf02550.aspx
\begin{itemize}
\item<1-| handout:1> \small CLR 是一种基于栈的虚拟机，并维护一个用于创建对象的堆
\item<2-| handout:1> \small 函数调用时自动分配的内存在栈中，当函数返回时自动释放
\item<3-| handout:1> \small 自由创建的对象在堆中，栈中只有堆中地址的引用 (\textit{reference}) \\
  \small 堆中分配的对象不会自动释放，而是由垃圾回收负责
\item<4-| handout:1> \small 在栈中分配的变量是值类型的，而堆中的是引用类型
\end{itemize}

\begin{columns}
  \column{.5\textwidth}
  \begin{figure}[h] \only<1| handout:1>{\label{fig:cts-v-r-types}} 
    \centering \input{pgf-dn/cts-v-r-types}
  \end{figure}
  \column{.5\textwidth}
  \begin{itemize}
  \item<1-| handout:1> \small 托管栈 --- \textit{Managed Stack}
  \item<1-| handout:1> \small 托管堆 --- \textit{Managed Heap}
  \item<4-| handout:1> \small 值类型 --- \textit{Value Type}
  \item<4-| handout:1> \small 引用类型 --- \textit{Reference Type}
  \end{itemize}

\end{columns}
  % 托管代码执行过程中，变量可以在托管栈或托管堆中分配。
  % 当方法被调用时，局部变量或方法创建的值类型变量都在栈中分配，当方法运行结束时都自动的释放；           
  % 而在堆中分配的变量，并不自动释放，而是通过“垃圾处理”来由CLR管理并释放。

  % 值类型的变量在栈中分配，而引用类型的变量在栈中只有一个引用，指向在堆中实际内存

\end{frame}

\begin{frame}
\frametitle{公共语言规范}
  \begin{block}{\textit{Common Language Specification(CLS)}}
    \CJKindent 语言互操作的最终规范，定义了遵循 ~CLR 的编译器必须包含的最小特性集，保证语
    言之间的通信。% CTS 的一个子集。
  \end{block}

  \begin{exampleblock}{部分 ~CLS 特性和规则}<2-| handout:1>
    %\rowcolors{1}{RoyalBlue!20}{RoyalBlue!5}
    \begin{tabular}{l|l}
      \hline
      \multicolumn{1}{c|}{\hei特\ \ 性} & \multicolumn{1}{c}{\hei 规\ \ 则}\\\hline
      可见性       & 定义类型的程序集之外有效 \\
      字符和大小写 & 变量除了大小写不同之外，还需要有其他区别 \\
      基本类型     & Byte, Int, Single, Double, Boolean 等 \\
      构造函数调用 & 访问实例数据前，必须调用基类的构造函数 \\
      数组边界     & 数组的各个维下界必须为 ~0 \\
      枚举         & 基类型必须是 ~Byte, Int16, Int32 或 ~Int64 \\
      方法签名     & 签名中返回值和参数的类型必须遵循 ~CLS \\
    \end{tabular}
  \end{exampleblock}

\end{frame}

%\subsection*{托管代码的编译}
\begin{frame}<0| handout:0>
\frametitle{CLR 中程序的运行}
  \begin{itemize}
  \item CLR 定义了一种基于栈的虚拟机
  \item CLR 上执行的代码是 ~CIL 编写的托管代码
  \item CIL 通过 ~JIT 实时的编译为本地代码
  \item CLR 是负责托管代码执行的虚拟运行环境
  \item MSIL 是 ~CIL 的一种实现
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Microsoft 中间语言}
%什么是 Microsoft 中间语言 (MSIL)？

\begin{block}{\textit{Microsoft Intermediate Language}}
  \CJKindent MSIL 是与 ~CPU 无关的指令集，它包含加载、存储、初始化和调用对象方法
  的指令，相当于 ~CLR 的汇编语言。
\end{block}

\begin{itemize}
\item \small .NET 框架程序被编译成生成 ~MSIL 和元数据
\item \small MSIL，元数据，CTS 结合，允许真正的跨语言集成
\item \small MSIL 在执行前被转换为机器代码，而不是边解释边执行
\end{itemize}

\begin{figure}[h] \only<1| handout:1>{\label{fig:clr-compile}}
  \centering \input{pgf-dn/clr-compile}
\end{figure}

\end{frame}

\begin{frame}
\frametitle{托管代码的实时编译}
\begin{overlayarea}{\textwidth}{1.2cm}
  \begin{itemize}
  \item \small
    \only<1| handout:0> {当托管代码调用其他模块或方法时， ~CLR 自动寻找并将其加载}
    \only<2| handout:0> {然后跳转到该方法的入口，首先调用 ~\texttt{\_CorExeMain()} 方法，通过它检查当前代
      码是否已经被编译为本地代码}
    \only<3| handout:0> {如果没有编译，则调用 ~JIT 编译器，把当前方法的 ~MSIL 编译为本地代码}
    \only<4| handout:0> {并将原来加载 ~MSIL 代码替换为本地代码}
    \only<5| handout:0> {因为已经替换了内存中的内容，所以 ~MSIL 加载之后，只需编译一次 }
    \only<6| handout:0> {当方法再次被调用时，可以直接执行，不需再次编译}
    \only<0| handout:1> {已经编译的本地代码会替换内存中的 ~MSIL，因此无需再次编译}
  \end{itemize}
\end{overlayarea}

\begin{figure}[h] \only<1| handout:1>{\label{fig:clr-execute}}
  \centering \input{pgf-dn/clr-execute}
\end{figure}

\end{frame}

% 程序集
% 什么是程序集？

% 程序集是 .NET 框架应用程序的主要构造块。它是作为一个单一实现单元（包含一个或多
% 个文件）来创建、标识和部署的功能集合。所有的托管类型和资源都可以被标记为仅在其
% 实现单元内访问，或者标记为可由该单元以外的代码来访问。

% 程序集通过清单来进行自我说明。清单是每个程序集的不可或缺的组成部分。清单：

% 建立程序集标识（以文本名称的格式）、版本、类别和数字签名（如果要在应用程序之间
% 共享该程序集）。

% 定义组成程序集实现的文件（通过名称和文件散列）。

% 指定组成程序集的类型和资源，包括哪些是从程序集中导出的。

% 逐条记录编译时对其他程序集的依存。

% 指定程序集正确运行所需要的权限的集合。

% 此信息在运行时用于解析引用、强制版本绑定策略以及验证所加载的程序集的完整性。因
% 为每一类型都被加载到程序集的上下文中，所以运行时可以确定并定位任何正在运行的对
% 象的程序集。程序集也是应用了代码访问安全权限的单元。在确定授予其所包含的代码哪
% 些权限时，每个程序集的标识证据都被认为是独立的。

\begin{frame}
\frametitle{程序集}
  \begin{block}{\textit{Assembly}}
    \CJKindent \small .NET 框架应用程序中，由一个或一组文件构成的，单一功能的
    逻辑单元。程序集是组件复用，实施安全策略的最小单位。
  \end{block}
  \begin{itemize}
  \item 程序集可以有一个或多个文件
  \item 程序集都有一个{\color{red!65!black}清单} (\textit{manifest}{})
  \item 清单描述程序集的内容信息
    \begin{enumerate}
    \item 程序集的名字
    \item 版本号，形如 ~major.minor.build.revision
    \item 支持的语言
    \item 程序集其他文件列表
    \item 所依赖的其他程序集及版本号
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}[t]
\frametitle{程序集的清单}

  \begin{itemize}
  \item 清单就是程序集的元数据，描述程序集包含的内容
  \item 如 ~DLL 文件，EXE 文件，图片文件，数据文件等
  \item 而程序集的清单只在其中一个文件中
  \end{itemize}

  \begin{onlyenv}<2-| handout:1>
    \begin{center}
      \includegraphics{assembly1.pdf}
    \end{center}
  \end{onlyenv}
\end{frame}

\begin{frame}
\frametitle{程序集的功能}
  \begin{itemize}
  \item 程序集定义了类型的有效范围， ~CLR 通过程序集查找类
  \item 程序集不需要注册表项， ~CLR 通过一种算法查找程序集 
  \item 安装 ~.NET 应用程序，只拷贝它的程序集即可
    % 安装与卸载 ~.NET 模块不需要修改系统注册表，只需 ~copy or delete
  \item 程序集可以有一个增强型名称 (\textit{Strong name})，用作共享名称
    \begin{itemize}
    \item 除了三个必须的成员之外，还要有数字签名和相应的公钥
    \item 通过数字签名，可以确保程序集的唯一性，增加安全性
    \end{itemize}

  \item 允许不同版本的程序集并存，可有效避免 ~DLL Hell
    % 因为程序集需要指定版本号，而程序集的依赖也如此
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{程序集的种类}
% http://www.microsoft.com/china/msdn/archives/library/faq111700.asp

\begin{block}{专用程序集}
  \CJKindent \small 专用程序集仅由单一应用程序使用，并且存储在该应用程序的安装目录中（或其子目录中）。要求在使
  用它的应用程序中是唯一的。
\end{block}

\begin{block}{共享程序集}
  \CJKindent \small 共享程序集是可被多个应用程序引用的程序集，通常被明确安装在全局程序集缓存 (\textit{Global
    Assembly Cache, GAC})中。要共享一个程序集，该程序集必须明确为这个目的而创建，这可以通过给其指定加密的增强型名称
  来实现。
\end{block}

\begin{itemize}
\item 通过区分专用和共享程序集，确定如何部署 (\textit{Deploy}) 程序集
\item 根据增强型名称，判断是否接受程序集，或新的版本
\item 根据版本管理特性，保证下载的代码不会影响本地应用程序的执行
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{程序集的加载过程}
  \begin{itemize}
  \item 只有在需要的时候加载，程序集可以在本地或网络中
    % 如果依赖程序集没有调用，不会被加载；
    % 程序集甚至不需在目标机器上

  \item CLR 通过特定的规则寻找需要的程序集
    
    \begin{enumerate}
    \item CLR 检查是否已经被加载，如果已经加载，结束查找
    \item 在全局程序集缓存(GAC)中查找
    \item 在程序代码中指定的位置查找
    \item 如果代码没有指定，在应用程序目录查找
    \item 根据 ~.NET 的配置，在其他目录或 ~URL 查找
    \item 如果都未找到，报告错误，结束查找
    \end{enumerate}

  \item 找到程序集后，检查增强名(如果有)，加载并使用
  \end{itemize}
\end{frame}

\section{.NET 框架类库}
% 名子空间
% 
\begin{frame}
  Microsoft .NET 框架提供了功能丰富的类库，这些类库 ~.NET 框架应用程序的基础。这
  些类库的应用十分广泛，从基本的输入输出，文本处理，到数据库应用、 ~Web应用一应俱
  全。
% 学习 ~.NET 开发的过程，基本上也是学习 ~.NET FCL 的过程
\end{frame}

\begin{frame}
\frametitle{命名空间的结构}

  \begin{itemize}
  \item 类库结构是一个命名空间(namespace)的树形结构
  \item 命名空间 ~System 是树形结构的根
  \item 命名空间下可以有子命名空间或类(class)
  \item 命名空间或类之间通过``.''连接
  \end{itemize}

\begin{figure}[h] \label<1| handout:1>{fig:fcl-namespaces}
\centering \input{pgf-dn/fcl-namespaces}
\end{figure}

\end{frame}

\begin{frame}
\frametitle{基本的类库简介}
  \begin{itemize}
  \item System.IO -- 文件或目录的访问

    基本的输入输出，文件、目录以及内存数据流的访问。

  \item System.Net -- 网络数据的访问

    使用各种网络协议 ~HTTP, FTP, Mail, 基本的 ~Socket 等进行网络数据通信，简化了
    网络应用程序的开发。

  \item System.Text -- 文本处理

    提供不同编码文本之间的转换功能，文本处理功能，正则表达式搜索及匹配文本等等。

  \item System.Data -- ADO.NET 的基础

    实现了 ~ADO.NET 的类库，用于访问各种数据源，比如 ~System.Data.SqlClient,
    System.Data.OracleClient, System.Data.ODBC等等。

    % System.Threading, System.Web, System.Windows, System.XML

  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{开发的方便性}
  传统的Windows开发 和 .NET 中 Windows 开发
\end{frame}

\begin{frame}
\frametitle{.NET 编程语言}
%超过20种，同样的开发界面、调试方式、同样的类库
\end{frame}


%\subsection*{受管开发环境}

%\subsection*{垃圾回收}

\section{.NET 语言}



% Local Variables: 
% mode: LaTeX
% TeX-master: "lesson-01.tex"
% TeX-header-end: "% End-Of-Header$"
% TeX-trailer-start: "% Start-Of-Trailer$"
% fill-column: 100
% coding: gb2312-dos
% End:
