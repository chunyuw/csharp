%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn>

\section{面向对象的设计}

\subsection{类的继承、基类的覆盖和访问}
% 继承，封装，重载

\begin{frame}[fragile] \frametitle{类的继承}
  \begin{onlyenv}<1> 继承是面向对象的一个术语，表示一个类（派生类）怎样从另一个
    类（基类）中共享特性和行为的方法。
\begin{lstlisting}[escapeinside=<>]
class Circle { 
  public int R; 
  public static double pi = 3.1415;
  public double Area(){
    return pi * R * R;
  }
}
class Ring : Circle {
  public int r; // <内半径>
}
\end{lstlisting}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{itemize}
    \item 建立类的层次结构，公用的功能放在基类
    \item 重用基类的字段和代码
    \item C\#~只允许单继承
    \item 通过~sealed~修饰的密封类，不能被继承
    \end{itemize}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile,t] \frametitle{覆盖基类方法}
  \begin{itemize}
  \item<1-> 使用~new~关键字
  \item<2> 虚方法(virtual)和覆盖(override)
  \end{itemize}
\begin{onlyenv}<1>
\lstset{emph={new,Area}}
\begin{lstlisting}
class Circle      { public int R; 
  public static double pi = 3.1415;
  public double Area()
    { return pi * R * R;}
}
class Ring:Circle { public int r;
  public new double Area()
    { return pi * R * R - pi * r * r; }
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<2>
\lstset{emph={virtual,override,Area}}
\begin{lstlisting}
class Circle      { public int R; 
  public static double pi = 3.1415;
  public virtual double Area()
    { return pi * R * R; }
}
class Ring:Circle { public int r;
  public override double Area()
    { return pi * R * R - pi * r * r; }
}
\end{lstlisting}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile,t] \frametitle{访问基类成员}
  \begin{itemize}
  \item<1-> 使用~this~关键字表示当前类
  \item<2> 使用~base~关键字表示基类
  \end{itemize}
    \begin{onlyenv}<1>
\lstset{emph={this}}
\begin{lstlisting}
class Circle {  
  public int R; 
  public static double pi = 3.1415;
  public Circle(int R){ 
    this.R = R;
  }
}
\end{lstlisting}
    \end{onlyenv}
    \begin{onlyenv}<2>
\lstset{emph={base}}
\begin{lstlisting}
class Ring : Circle {
  public int r;
  public override double Area(){ 
    return base.Area() - pi * r * r;
  }
}
\end{lstlisting}
    \end{onlyenv}
\end{frame}

\subsection{抽象类、接口}

\begin{frame}[fragile,t] \frametitle{抽象类}
  \begin{onlyenv}<1>
    \begin{itemize}
    \item 用 abstract 修饰，不能生成实例
    \item 可以只给出方法的声明，无具体实现
    \item 而具体实现由派生类完成
    \end{itemize}
  \end{onlyenv}
  \begin{onlyenv}<1-2>
\lstset{emph={abstract}}
\begin{lstlisting}
public abstract class Graphics{
  public static double pi = 3.14159;
  public abstract double Area();
  public abstract double Perimeter();
}
\end{lstlisting}
  \end{onlyenv}
  \begin{onlyenv}<2>
\lstset{emph={override}}
\begin{lstlisting}
class Circle:Graphics {
  public int r = 2;
  public override double Perimeter(){
    return 2 * pi * r;
  }
  public override double Area(){
    return pi * r * r;
  }
}
\end{lstlisting}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile] \frametitle{接口(interface)}
  \begin{onlyenv}<1> 
    \begin{block}{接口}
      能声明特性、索引器、事件和方法的特殊结构，只为这些成员提供定义，没有具体
      实现。
    \end{block}
\end{onlyenv}
\begin{onlyenv}<1-3>
\lstset{emph={interface},emph={[2]Perimeter,Area}}
\begin{lstlisting}
public interface IMeasurement{
  double Area();
  double Perimeter();
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<2>
\lstset{emph={[2]Perimeter,Area}}
\begin{lstlisting}
class    Circle:IMeasurement {
  public int r = 2;
  public static double pi = 3.14159;
  public double Perimeter(){
    return 2 * pi * r;
  }
  public double Area(){
    return pi * r * r;
  }
}
\end{lstlisting}
  \end{onlyenv}
  \begin{onlyenv}<3>
\lstset{emph={[2]Perimeter,Area}}
\begin{lstlisting}
class Rectangle:IMeasurement {
  public int width,height;
  public double Perimeter(){
    return 2 * (width + height);
  }
  public double Area(){
    return width * height;
  }
}
\end{lstlisting}
  \end{onlyenv}
  \begin{onlyenv}<4>
    \begin{block}{接口的特点}
      \begin{itemize}
      \item 为类提供了蓝图，规范了类之间的交互方式
      \item 可以继承其他接口
\lstset{emph={MyIf},emph={[2]BaseIf}}
\begin{lstlisting}
public interface MyIf:BaseIf
  { ... }
\end{lstlisting}
      \item 和抽象类一样，不可以生成实例
      \item 接口成员默认为 public 和 abstract
      \end{itemize}
    \end{block}
  \end{onlyenv}
  \begin{onlyenv}<5>
    \begin{block}{接口和抽象类的区别}
      \begin{itemize}
      \item 只有四种成员，仅提供定义而不实现
      \item 定义不需要 public 和 abstract，实现不需要 override
      \item 类只能继承一个类，但可以实现多个接口
\lstset{emph={MyClass},emph={[2]FirstIf,AnotherIf}}
\begin{lstlisting}
class MyClass:FirstIf,AnotherIf
  { ... }
\end{lstlisting}
      \end{itemize}
    \end{block}
  \end{onlyenv}
\end{frame}

\begin{frame} \frametitle{总结}
  \begin{columns}
    \column{.5\textwidth}
    \begin{block}{C\#的基本元素}
      \begin{itemize}
      \item 基本语法
      \item 数据类型
      \item 类型转换
      \item 流程控制
      \item 异常处理
      \end{itemize}
    \end{block}
    \column{.5\textwidth}
    \begin{block}{C\#的类}
      \begin{itemize}
      \item 类的成员
      \item 成员的访问限制
      \item 类的继承和派生
      \item 抽象类和接口
      \item 命名空间
      \end{itemize}
    \end{block}
  \end{columns}
\end{frame}

% Local Variables: 
% mode: LaTeX
% coding: gb2312
% TeX-master: "lesson-02.tex"
% End:
