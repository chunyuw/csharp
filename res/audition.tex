%% slides of .NET Programming by Chunyu Wang <chunyu@hit.edu.cn>

\documentclass[14pt,cjk,color=usenames]{beamer}
% notes,serif,hyperref={CJKbookmarks=true}
\mode<presentation>
{
  \setbeamertemplate{background canvas}[vertical shading][bottom=red!10,top=blue!10]
  \usetheme{Warsaw}
%   \usefonttheme[onlysmall]{structurebold}
}


\usepackage{CJK}
\usepackage{ccmap}
\usepackage{pgf}
% \usepackage{pgf,pgfarrows,pgfnodes,pgfautomata,pgfheaps,pgfshade}
% \usepackage{hyperref}
% \usepackage{amsmath,amssymb}
\usepackage[latin1]{inputenc}
% \usepackage{colortbl}
\usepackage[usenames]{color}
% \usepackage{xcolor}
\usepackage[english]{babel}
\usepackage{times}
\usepackage{listings}

% \usepackage{pgfpages}
% \setbeameroption{show notes on second screen}

\hypersetup{pdfpagemode=FullScreen}
\setbeamercovered{dynamic}

\lstdefinelanguage{CSharp}
{morekeywords={abstract, as, base, bool, break, byte, case, catch, char,
    checked, class, const, continue, decimal, default, delegate, do, double,
    else, enum, event, explicit, extern, false, finally, fixed, float, for,
    foreach, get, goto, if, implicit, in, int, interface, internal, is, lock,
    long, namespace, new, null, object, operator, out, override, params,
    private, protected, public, readonly, ref, return, sbyte, sealed, set,
    short, sizeof, stackalloc, static, string, struct, switch, this, throw,
    true, try, typeof, uint, ulong, unchecked, unsafe, ushort, using, value,
    virtual, void, volatile, while},
otherkeywords={:},
sensitive=true,
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]",
}
\lstset{basicstyle=\small\ttfamily,
        keywordstyle=\color[rgb]{0.15,0.25,0.55}\bfseries,
        identifierstyle=,
        stringstyle=\color[rgb]{0.41,0.13,0.55}\ttfamily,
        commentstyle=\color[rgb]{0.55,0.14,0.14}\sl,
        emphstyle=\color[rgb]{0.75,0,0}\bfseries,
        emphstyle={[2]\color[rgb]{0,0.55,0}\bfseries},
        frameround=tttt,
        frame=single,
        framerule=1pt,
        rulecolor=\color[rgb]{0.18,0.55,0.34},
        backgroundcolor=\color{red!10}, %\color[rgb]{0.94,0.85,0.71},
        escapebegin=\small\CJKfamily{li}\sl\color[rgb]{0.55,0.14,0.14},
        escapeend=,
        language=CSharp}

\pgfdeclaremask{hit-mask}{logo/hit-mask}
\pgfdeclareimage[mask=hit-mask,width=1.3cm]{hit-logo}{logo/hit-logo}
\pgfdeclaremask{cs-mask}{logo/cs-mask}
\pgfdeclareimage[mask=cs-mask,width=1.3cm]{cs-logo}{logo/cs-logo}
\logo{\vbox{\hbox to 1.3cm{\hfil\pgfuseimage{cs-logo}}\vskip0.1cm\hbox{\pgfuseimage{hit-logo}}}}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\begin{CJK*}{GBK}{li}

\title[.NET~程序设计~---~C\#~语言]{.NET~程序设计~---~C\#~语言}
\author[chunyu@hit.edu.cn]{王春宇}
\institute[哈尔滨工业大学]{计算机科学与技术学院\\软件基础教研室}
\date[2006-07-13]{2006年7月13日}
\subject{C\# 语言基础}

\frame{\titlepage}

\part<presentation>{语法}

\begin{frame}
\tableofcontents
\end{frame}

\section{C\#语言简介}

\begin{frame} \frametitle{C\#语言简介}
  \begin{itemize}
  \item<1-> 面向对象\\语言本身支持抽象类、接口、特性和事件等
  \item<2-> 基于组件的开发\\提供内置的版本支持，接口与实现分离，事件的发布与订阅等
  \item<3-> 与~Web~开发相结合\\可以将组件转变为~Web~服务，支持远程调用等
  \item<4-> 更高的效率\\垃圾自动回收，变量是类型安全的，变量自动初始化等
  \item<4-> 支持局部类、泛型等高级特性
  \end{itemize}
\end{frame}
\note{
  \begin{itemize}
  \item C\#是一门较新的语言，在面向对象编成比较热的时候诞生，因此支持面向对象的
    各种概念。
  \item 支持比较现代的软件开发的方法，组件开发
  \item 值得一提的是进行 Web Service 的开发
  \item 和 Java 类似，但优于Java，除支持垃圾自动回收等，还支持局部类泛型等
  \end{itemize}
}

\section{C\#的基本语法}
\subsection{变量、数组、注释等}

\begin{frame}[fragile] \frametitle{C\# 语言的语法}
\begin{itemize}
\item 与~C~族语言类似(C/C++/Java)
\pause
\item 标识符对大小写敏感
\pause
\item 变量的声明、创建类的实例
\begin{lstlisting}
int    a = 10;
Circle b = new Circle();
\end{lstlisting}
\pause
\item 注释有三种风格
\begin{lstlisting}
/* multi-line comments */
// single-line comments
/// <summary> XML comments </summary>
\end{lstlisting}
通过~XML~注释，可自动生成程序文档
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item 语法类似 C/C++/Java
  \item 同样的变量声明，创建类实例，如例子所示
  \end{itemize}
}

\begin{frame} \frametitle{简单数据类型(Primitive Data Types)}
\begin{itemize}
\item 字符串型：string
\item 布尔型~bool：值为~true~或~false \pause
\item 字符型~char：长度为 2 字节(Unicode字符) \pause
\item 整数型：\\byte, sbyte, short, ushort, int, uint, long, ulong \pause
\item 浮点型：float, double, decimal \pause
\item 枚举类型：enum
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item C\# 中有较丰富的数据类型
  \item 新的内置数据类型 string 和 bool，bool长度为 1 字节，值为 true/false
  \item 分别支持 1/2/4/8 字节长的整型
  \item 以及 4/8/16 字节长的浮点型
  \end{itemize}
}

\begin{frame}[fragile] \frametitle{结构体(struct)类型}
结构体是和类(class)相似的一种简单的封装构造，同样可以包含成员变量和方法。
\begin{lstlisting}[escapeinside=<>]
struct Point {
  int x,y;
  public Point(int X, int Y)
    { x=X;  y=Y;}
}
\end{lstlisting}
\begin{itemize}
\item 结构体不能定义无参数的构造函数，不能定义析构函数
\item 如果定义构造函数，必须为结构体中的每个字段赋值
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item 也支持 struct，和 class 类似
  \end{itemize}}

\begin{frame}[fragile] \frametitle{数组}
\begin{itemize}
\item 一维数组
\begin{lstlisting}[escapeinside=<>]
int[] x; // <声明一个数组变量>
int[] y = new int[4]; // <创建数组>
int[] z = new int[] {1,3,5}; // <初始化>

\end{lstlisting}
\pause
\item 矩形多维数组
\begin{lstlisting}[escapeinside=<>,mathescape]
int[,] y = new int[4,3]; // $4\times3$ <的数组>

\end{lstlisting}
\pause
\item 锯齿形多维数组
\begin{lstlisting}[escapeinside=<>]
int[][] z = new int[2][];
     z[0] = new int[3]; // z[0]<长度为3>
     z[1] = new int[5]; // z[0]<长度为3>
//z[0]<只是数组变量；>z[0][0]<才是整数>

\end{lstlisting}
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item 数组的声明稍有不同，不过和 Java 类似
  \item int[]表示类型，需要创建实例
  \item int[,] 和 int[][]不同
  \end{itemize}
}

\begin{frame}[fragile] \frametitle{溢出检查(checked和unchecked)}
\begin{itemize}
\item 进行溢出检查
\lstset{emph={checked,unchecked}}
\begin{lstlisting}[escapeinside=<>]
int i = 1000000, j = 1000000;
int x = checked(i*j);
//<发生运行时异常：>System.OverflowException

\end{lstlisting}
\pause
\item 不进行溢出检查
\begin{lstlisting}[escapeinside=<>]
int i = 1000000, j = 1000000;
int x = unchecked(i*j);
//<无异常出现，但> x=-727379968

\end{lstlisting}
\end{itemize}
\end{frame}

\subsection{流程控制、异常处理}

\begin{frame}[fragile] \frametitle{分支语句}
  \begin{onlyenv}<1-2>
    \begin{itemize}
    \item if-else 语句
\begin{lstlisting}
  if (a>=b){
    x =  1;
  } else if (a<b) {
    x = -1;
  }
\end{lstlisting}
\pause
    \item 判断条件的值必须是 bool 型的 true 或 false
\begin{lstlisting}[escapeinside=<>]
  int i = 1;
  if (i) { ... }
  // <编译错误：无法隐式的将~int~转为~bool>
\end{lstlisting}
    \end{itemize}
  \end{onlyenv}

  \begin{onlyenv}<3>
    \begin{itemize}
    \item switch 语句
    \end{itemize}
      \begin{columns}
        \column{.5\textwidth}
\begin{lstlisting}
int Score; string r;
switch(Score/10){
  case 10:
  case 9:  
    r = "A"; break;
  case 8:  
    r = "B"; break;
  ...
  default: 
    r = "E"; break;
}

\end{lstlisting}
        \column{.5\textwidth}
\begin{lstlisting}
int Score; string r;
switch(Score/10){
  case 10:
    r = "A+"; 
    goto case 9;
  case 9:  
    r = "A"; break;
  ...
  default: 
    r = "E"; break;
}

\end{lstlisting}
      \end{columns}
  \end{onlyenv}
\end{frame}
\note{
  \begin{itemize}
  \item case 语句之间
  \item 如果语句为空，可以自动进入下一个 case 语句
  \item 如果不空必须显示使用 goto case xx; 语句
  \end{itemize}
}
\begin{frame}[fragile] \frametitle{循环语句}
\begin{itemize}
\item while/do-while 循环
\begin{lstlisting}
while (condition) { ... }
do { ... } while (condition);
\end{lstlisting}
\pause
\item for 循环
\begin{lstlisting}
for(int i=0; i<5; i++) { ... }
\end{lstlisting}
\pause
\item foreach 循环
\begin{lstlisting}
string[] colors={"Red","Green","Blue"};
foreach (string x in colors) {
  Console.WriteLine(x);
}
\end{lstlisting}
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item foreach 和 VB 中的类似，用来对数组中的每个元素进行迭代
  \item 使用 foreach 可以省去使用索引变量的麻烦，也不用判断数组的长度
  \end{itemize}
}

\begin{frame} \frametitle{跳转语句}
\begin{itemize}
\item break \\用来退出 while, do-while, for 和 foreach 循环以及 swich 分支语句等；
\item continue \\用来中断循环的当前迭代，并继续循环；
\item goto \\任意跳转；
\item return \\返回方法的调用；
\end{itemize}
\end{frame}

\begin{frame}[fragile] \frametitle{异常处理(try-catch-finally)}
捕捉和处理可能在运行时发生的错误的技术，常见的异常有整数溢出、下标越界、IO错误等。\pause
\begin{itemize}
\item try 监测异常的发生
\begin{lstlisting}
try { ... }
\end{lstlisting}
\pause
\item catch 捕获并处理异常
\begin{lstlisting}[escapeinside=<>]
catch (SomeException e) { 
  // <处理> SomeException <类型的异常> e
}

\end{lstlisting}
\pause
\item finally 确保必要操作一定会执行
\begin{lstlisting}
finally { ... }
\end{lstlisting}
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item 以一种优雅的方式处理错误
  \item 可以将正常代码和错误处理代码分开
  \end{itemize}}

\begin{frame}[fragile] \frametitle{异常处理举例}
\begin{lstlisting}
// using System; using System.IO;
StreamWriter sw = null;
try {
  sw = new StreamWriter(
    new FileStream("T.txt",FileMode.Open));
  sw.WriteLine ("Hello World");           
}
catch (FileNotFoundException e) {
  Console.WriteLine("File "
               +e.FileName+" not found.");
}
catch (Exception e){ Console.WriteLine(e);}
finally { if (sw!=null)   sw.Close();     }

\end{lstlisting}
\end{frame}

\note{
  \begin{itemize}
  \item 例子中打开文件处可能发生错误，如文件不存在，或者不可读
  \item 当不存在时，在第一个catch处捕获，并处理
  \item 其他任何错误，都会被更通用的异常类型捕获
  \item finally保证，无论是否发生异常，此处代码都会被执行
  \end{itemize}}

\part<presentation>{类}

\begin{frame}
\tableofcontents
\end{frame}

\section{类的使用}

\subsection{类的基本组成}

\begin{frame}[fragile] \frametitle{一个简单的例子}
\lstset{emph={class,new},emph={[2]Main}}
\begin{lstlisting}
class Circle {
  public int R;
  public static double pi = 3.14159;
  public double Perimeter(){
    return 2 * pi * R;
  }
}
class test {
  static void Main(){
    Circle c = new Circle();
    c.R = 20;
    System.Console.WriteLine(c.Perimeter());
  }
}
\end{lstlisting}
\end{frame}

\note{
  \begin{itemize}
  \item 这里是一个类的例子，也是一个应用程序的例子
  \item class 来定义类，new 关键字创建实例
  \item C\#中，没有全局的函数和变量，都必须放在类中，即使是 Main()函数
  \item Main() 函数必须是 static 的，而且首字母大写
  \end{itemize}}

\begin{frame} \frametitle{类的成员}
  \begin{onlyenv}<1>
    \begin{block}{字段 - fields}
      描述对象属性的简单数据类型、自定义的结构或其他类。
    \end{block}
    \begin{block}{方法 - methods}
      对象中执行计算或其他操作的函数成员。
    \end{block}
    \begin{block}{特性 - properties}
      对类中字段提供特定的访问方法。
    \end{block}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{block}{委托 - delegates}
      运行时用来动态调用不同的方法的特殊成员。
    \end{block}
    \begin{block}{事件 - events}
      建立程序之间的连接方法和运行过程的终结操作。
    \end{block}
    \begin{block}{索引器 - indexers}
      通过方括号的语法访问成员的方法。
    \end{block}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile] \frametitle{静态成员和实例成员}
  \begin{onlyenv}<1>
    \begin{itemize}
    \item 静态成员使用关键字~static~修饰，否则为实例成员
\lstset{emph={static}}
\begin{lstlisting}[escapeinside=<>]
class Circle {
  // <实例变量>
  public int R; 
  // <静态变量>
  public static double pi = 3.14159; 
  // <实例方法>
  public double Perimeter(){
    return 2 * pi * R;
  }
}
\end{lstlisting}
    \end{itemize}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{itemize}
    \item 静态成员通过类名访问，实例成员通过对象名访问
\begin{lstlisting}[escapeinside=<>]
Circle c  = new Circle(); // <创建一个实例>
Circle.pi = 3.14159265;   // <访问静态变量>
      c.R = 100;          // <访问实例变量>

\end{lstlisting}
    \item 静态成员和具体实例无关，是类本身的特征
    \item 通过静态变量，可以在类的实例之间共享信息
    \end{itemize}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile] \frametitle{常量和只读变量}
  \begin{itemize}
  \item 分别使用~const~和~readonly~修饰
  \item 常量在编译时初始化，只读变量在运行时初始化
  \item 初始化之后，都不可以被修改
  \item 引用类型只能使用只读变量，因为无法在编译时初始化
  \end{itemize}
\lstset{emph={readonly,const}}
\begin{lstlisting}
  const    string url1="www.hit.edu.cn";
  readonly string url2="www.cs.hit.edu.cn";
\end{lstlisting}
\end{frame}

\begin{frame} \frametitle{方法(methods)}
\begin{itemize}
\item 方法是一个命名的代码块，用于计算或其他操作的函数成员
\item 分为实例方法和静态方法
\item 方法可以被声明为 virtual、abstract 或 sealed
\item 方法可以被继承、覆盖和隐藏
\end{itemize}
\end{frame}

\begin{frame}[fragile] \frametitle{构造函数(constructors)}
构造函数是一个（或多个）特殊的方法，用于初始化对象。可以分为静态构造函数
和实例构造函数两种。
\pause
\begin{itemize}
\item 构造函数名字与类名相同，但无返回类型
\begin{lstlisting}[escapeinside=<>]
class Circle { public int R;
  // <初始化为单位圆，实例构造函数>
  public Circle() { R=1;}    }
\end{lstlisting}
\pause
\item 静态构造函数(用static修饰)，在加载类时调用，用于初始化静态变量
\end{itemize}
\end{frame}
\note{
  \begin{itemize}
  \item 构造函数的定义不是必须的
  \end{itemize}
}

\begin{frame}[fragile] \frametitle{析构函数(destructors)}
析构函数是当对象被清除时被调用的特殊方法。
\begin{itemize}
\item 名字以字符“\verb|~|”开始的类名，无返回类型
\begin{lstlisting}[escapeinside=<>]
class Circle {
  public int R;
  public Circle() { R=1;}
  ~Circle() { /* <析构函数体> */  } 
}
\end{lstlisting}
\pause
\item 由于 C\# 的垃圾回收是自动的，往往不需要自己创建析构函数
\pause
\item 构造函数和析构函数的定义都不是必须的
\end{itemize}
\end{frame}

\begin{frame}[fragile] \frametitle{重载(overload)}
  \begin{block}{方法的重载}
    在同一个类中，定义同一名称的多个成员方法，被重载的成员方法之间的唯一差别就
    是具有不同的参数类型和参数数量。
\pause
    \begin{itemize}
    \item 索引器、构造函数、操作符都可以重载
    \item 调用时，C\#会根据参数列表的不同自动选择
    \end{itemize}
  \end{block}
\pause
\begin{lstlisting}[escapeinside=<>]
class Circle{   public int R;
  public Circle()      { R = 1;}
  public Circle(int x) { R = x;}
}  ...
  Circle a = new Circle();
  Circle b = new Circle(20);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile] \frametitle{特性(properties)}
  \begin{onlyenv}<1>
    \begin{block}{特性}
      对字段提供特定的访问方式，为类提供封装。
    \end{block}
    \begin{itemize}
    \item 特性的访问是透明的，类似成员变量
    \item get~提供读访问，set~提供写访问
    \item 通过特性可进行完整性检查，类似成员方法
    \end{itemize}
  \end{onlyenv}
  \begin{onlyenv}<2>
\lstset{emph={get,set}}
\begin{lstlisting}[escapeinside=<>]
class Circle {
  protected int R;
  public  int Radius {
    get { return R; }
    set { if(value>0) R=value; }  
  }
}
...
  Circle c = new Circle();
  c.Radius = 20;
  Console.WriteLine(c.Radius);

\end{lstlisting}
  \end{onlyenv}
\end{frame}

% \begin{frame}[fragile] \frametitle{委托(delegate)}
%   \begin{onlyenv}<1>
%     \begin{block}{委托}
%       具有特定返回类型和参数列表的方法的引用类型；方法可以有任何名字，可以使静
%       态或实例方法；对方法实际能进行的操作没有限制。
%     \end{block}
%     \begin{itemize}
%     \item 定义委托后，需要声明及创建委托的实例
%     \item 通过委托，程序可以在运行时动态的调用不同的方法
%     \end{itemize}
%   \end{onlyenv}
%   \begin{onlyenv}<2>
% \begin{lstlisting}[escapeinside=<>]
% // <定义委托 Compute>
% delegate int Compute (int a, int b);
% class Test {
%   public Compute comp;        // <声明委托>
%   public int add (int x, int y)
%     { return x + y; }
% } ...
%  Test n = new Test();
%  n.comp = new Compute(n.add); // <创建委托实例>
%  int r  = n.comp3 (20,40);    // <调用委托>
%  System.Console.WriteLine (r);
% \end{lstlisting}
%   \end{onlyenv}
% \end{frame}

% \begin{frame}[fragile] \frametitle{事件}
% \begin{itemize}
% \item ...
% \end{itemize}
% \end{frame}

\begin{frame} \frametitle{成员的访问限制}
C\#通过类成员的访问限制，能够完全控制谁能查看和使用类及类的成员。\pause

\begin{block}{访问修饰符的作用}
\begin{tabular}{l|l}
private       & 只有同一类的成员\\
protected     & 同一类和派生类的成员\\
internal      & 同一程序集的成员\\
protected internal & 同一程序集或派生类的成员\\
public        & 任何成员，不受限制的\\
\end{tabular}
\end{block}
\end{frame}

\subsection{类的层次结构、类型转换}

\setbeamerfont{table}{size=\small}
\begin{frame} \frametitle{所有类的基类：System.Object}
\begin{itemize}
\item C\#中的所有类型直接或间接的基类，也是 .NET Framework 中所有类的最终基类
\item 隐式继承，不需要在类的定义中声明
\end{itemize}
\pause
\begin{block}{为派生类提供的底层服务}
\usebeamerfont{table}
\begin{tabular}{l|l}
Equals()      & 确定两个对象实例是否相等\\
GetHashCode() & 生成对象相对应的数字以支持哈希表\\
ToString()    & 生成描述类的实例的可读文本字符串\\
GetType()     & 获取当前实例的类型\\
Finalize()    & 在自动回收对象之前执行清理操作\\
\end{tabular}
\normalfont
\end{block}
\end{frame}


\begin{frame}[fragile] \frametitle{值类型与引用类型}
\begin{itemize}
  \item 值类型，赋值或传递给一个方法时，生成一个新的实例
  \item 引用类型，赋值或传递给一个方法时，使用当前实例（只传地址）
\end{itemize}
\begin{lstlisting}[escapeinside=<>]
class Circle { public int R; }
...
  Circle c = new Circle();
  c.R = 10;
  Circle d = c;
  d.R = 20;
  Console.WriteLine(c.R); // <输出为> 20
\end{lstlisting}
\end{frame}

% \begin{frame} \frametitle{类型的层次结构}
% \color[rgb]{1,0,0} 31页层次结构图
% \end{frame}

\begin{frame}[fragile] \frametitle{类型之间的转换}
  \begin{block}{隐式转换}
    \begin{itemize}
    \item 当信息不会丢失时 \\如 int$\rightarrow$long 的转换，int$\rightarrow$float 的转换；
    \item 从派生类到基类的转换
    \end{itemize}
  \end{block}
\pause
  \begin{block}{显式转换}
    \begin{itemize}
    \item 当不能进行隐式转换时，必须使用显式转换
    \item 使用显式转换，也可以减少错误和异常
    \end{itemize}
  \end{block}
\pause
\begin{lstlisting}[escapeinside=<>]
  int  a = 5;
  long b = a;         // <隐式转换>
  int  c = (int) b;   // <显式转换>

\end{lstlisting}
\note{转换是指把对象从一种类型改变为另外一种类型的能力。}
\end{frame}

\begin{frame}[fragile] \frametitle{装箱(boxing)与拆箱(unboxing)}
  \begin{block}{装箱}
    \begin{itemize}
    \item 将值类型转换为引用类型的过程
    \item 系统为引用类型分配新内存，创建对象，并把值类型的内容复制到新分配的内存中。
    \end{itemize}
  \end{block}
\pause
  \begin{block}{拆箱}
    \begin{itemize}
    \item 将引用类型的对象转换为值类型的过程
    \item 拆箱过程必须是显式的
    \end{itemize}
  \end{block}
\pause
\begin{lstlisting}[escapeinside=<>]
  int    a = 5;
  object o = a;       // <隐式转换，装箱>
  int    b = (int) o; // <显式转换，拆箱>

\end{lstlisting}
\end{frame}

\begin{frame}[fragile,t] \frametitle{命名空间}
\begin{onlyenv}<1-2>
  \begin{block}{命名空间(namespace)}
    类、接口、委托等其他类型的一个逻辑上的组合，用来防止名字之间的命名冲突。
  \end{block}
\pause
  \begin{itemize}
  \item 定义命名空间
\lstset{emph={namespace}}
\begin{lstlisting}[escapeinside=<>]
namespace Animals{
  namespace Birds{
    public class Sparrow{
      // <类的具体实现>
    }
  }
}
\end{lstlisting}
  \end{itemize}
\end{onlyenv}

\begin{onlyenv}<3>
  \begin{itemize}
  \item 使用命名空间(using)
\lstset{emph={using}}
\begin{lstlisting}
using Animals.Birds;
...
  Sparrow s = new Sparrow();
\end{lstlisting}
  \item 使用别名(alias)
\lstset{emph={using}}
\begin{lstlisting}
using b = Animals.Birds;
...
  b.Sparrow s = new b.Sparrow();
\end{lstlisting}
  \end{itemize}
\end{onlyenv}
\end{frame}

\section{面向对象的设计}

\subsection{类的继承、基类的覆盖和访问}
% 继承，封装，重载

\begin{frame}[fragile] \frametitle{类的继承}
  \begin{onlyenv}<1> 继承是面向对象的一个术语，表示一个类（派生类）怎样从另一个
    类（基类）中共享特性和行为的方法。
\begin{lstlisting}[escapeinside=<>]
class Circle { 
  public int R; 
  public static double pi = 3.1415;
  public double Area(){
    return pi * R * R;
  }
}
class Ring : Circle {
  public int r; // <内半径>
}
\end{lstlisting}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{itemize}
    \item 建立类的层次结构，公用的功能放在基类
    \item 重用基类的字段和代码
    \item C\#~只允许单继承
    \item 通过~sealed~修饰的密封类，不能被继承
    \end{itemize}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile,t] \frametitle{覆盖基类方法}
  \begin{itemize}
  \item<1-> 使用~new~关键字
  \item<2> 虚方法(virtual)和覆盖(override)
  \end{itemize}
\begin{onlyenv}<1>
\lstset{emph={new,Area}}
\begin{lstlisting}
class Circle      { public int R; 
  public static double pi = 3.1415;
  public double Area()
    { return pi * R * R;}
}
class Ring:Circle { public int r;
  public new double Area()
    { return pi * R * R - pi * r * r; }
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<2>
\lstset{emph={virtual,override,Area}}
\begin{lstlisting}
class Circle      { public int R; 
  public static double pi = 3.1415;
  public virtual double Area()
    { return pi * R * R; }
}
class Ring:Circle { public int r;
  public override double Area()
    { return pi * R * R - pi * r * r; }
}
\end{lstlisting}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile,t] \frametitle{访问基类成员}
  \begin{itemize}
  \item<1-> 使用~this~关键字表示当前类
  \item<2> 使用~base~关键字表示基类
  \end{itemize}
    \begin{onlyenv}<1>
\lstset{emph={this}}
\begin{lstlisting}
class Circle {  
  public int R; 
  public static double pi = 3.1415;
  public Circle(int R){ 
    this.R = R;
  }
}
\end{lstlisting}
    \end{onlyenv}
    \begin{onlyenv}<2>
\lstset{emph={base}}
\begin{lstlisting}
class Ring : Circle {
  public int r;
  public override double Area(){ 
    return base.Area() - pi * r * r;
  }
}
\end{lstlisting}
    \end{onlyenv}
\end{frame}

\subsection{抽象类、接口}

\begin{frame}[fragile,t] \frametitle{抽象类}
  \begin{onlyenv}<1>
    \begin{itemize}
    \item 用 abstract 修饰，不能生成实例
    \item 可以只给出方法的声明，无具体实现
    \item 而具体实现由派生类完成
    \end{itemize}
  \end{onlyenv}
  \begin{onlyenv}<1-2>
\lstset{emph={abstract}}
\begin{lstlisting}
public abstract class Graphics{
  public static double pi = 3.14159;
  public abstract double Area();
  public abstract double Perimeter();
}
\end{lstlisting}
  \end{onlyenv}
  \begin{onlyenv}<2>
\lstset{emph={override}}
\begin{lstlisting}
class Circle:Graphics {
  public int r = 2;
  public override double Perimeter(){
    return 2 * pi * r;
  }
  public override double Area(){
    return pi * r * r;
  }
}
\end{lstlisting}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile] \frametitle{接口(interface)}
  \begin{onlyenv}<1> 
    \begin{block}{接口}
      能声明特性、索引器、事件和方法的特殊结构，只为这些成员提供定义，没有具体
      实现。
    \end{block}
\end{onlyenv}
\begin{onlyenv}<1-3>
\lstset{emph={interface},emph={[2]Perimeter,Area}}
\begin{lstlisting}
public interface IMeasurement{
  double Area();
  double Perimeter();
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<2>
\lstset{emph={[2]Perimeter,Area}}
\begin{lstlisting}
class    Circle:IMeasurement {
  public int r = 2;
  public static double pi = 3.14159;
  public double Perimeter(){
    return 2 * pi * r;
  }
  public double Area(){
    return pi * r * r;
  }
}
\end{lstlisting}
  \end{onlyenv}
  \begin{onlyenv}<3>
\lstset{emph={[2]Perimeter,Area}}
\begin{lstlisting}
class Rectangle:IMeasurement {
  public int width,height;
  public double Perimeter(){
    return 2 * (width + height);
  }
  public double Area(){
    return width * height;
  }
}
\end{lstlisting}
  \end{onlyenv}
  \begin{onlyenv}<4>
    \begin{block}{接口的特点}
      \begin{itemize}
      \item 为类提供了蓝图，规范了类之间的交互方式
      \item 可以继承其他接口
\lstset{emph={MyIf},emph={[2]BaseIf}}
\begin{lstlisting}
public interface MyIf:BaseIf
  { ... }
\end{lstlisting}
      \item 和抽象类一样，不可以生成实例
      \item 接口成员默认为 public 和 abstract
      \end{itemize}
    \end{block}
  \end{onlyenv}
  \begin{onlyenv}<5>
    \begin{block}{接口和抽象类的区别}
      \begin{itemize}
      \item 只有四种成员，仅提供定义而不实现
      \item 定义不需要 public 和 abstract，实现不需要 override
      \item 类只能继承一个类，但可以实现多个接口
\lstset{emph={MyClass},emph={[2]FirstIf,AnotherIf}}
\begin{lstlisting}
class MyClass:FirstIf,AnotherIf
  { ... }
\end{lstlisting}
      \end{itemize}
    \end{block}
  \end{onlyenv}
\end{frame}

\begin{frame} \frametitle{总结}
  \begin{columns}
    \column{.5\textwidth}
    \begin{block}{C\#的基本元素}
      \begin{itemize}
      \item 基本语法
      \item 数据类型
      \item 类型转换
      \item 流程控制
      \item 异常处理
      \end{itemize}
    \end{block}
    \column{.5\textwidth}
    \begin{block}{C\#的类}
      \begin{itemize}
      \item 类的成员
      \item 成员的访问限制
      \item 类的继承和派生
      \item 抽象类和接口
      \item 命名空间
      \end{itemize}
    \end{block}
  \end{columns}
\end{frame}

% \begin{frame}
% \frametitle{}
% \begin{itemize}
% \end{itemize}
% \end{frame}

\end{CJK*}
\end{document}

% Local Variables: 
% mode: LaTeX
% mode: Tex-Pdf
% coding: gb2312
% End:
