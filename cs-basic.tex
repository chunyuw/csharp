%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn>

\part{C\# 语言基础}

\section{C\# 语言简介}

\begin{frame}
\frametitle{C\# 语言简介}
\begin{itemize}
\item<1-| handout:1> 面向对象\\语言本身支持抽象类、接口、特性和事件等
\item<2-| handout:1> 基于组件的开发\\提供内置的版本支持，接口与实现分离，事件的发布与订阅等
\item<3-| handout:1> 与~Web~开发相结合\\可以将组件转变为~Web~服务，支持远程调用等
\item<4-| handout:1> 更高的效率\\垃圾自动回收，变量是类型安全的，变量自动初始化等
\item<4-| handout:1> 支持局部类、泛型等高级特性
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item C\#是一门较新的语言，在面向对象编成比较热的时候诞生，因此全面的支持面向
    对象开发。CTS 本身也是面向对象的系统
  \item 支持比较现代的软件开发的方法，组件开发
  \item 值得一提的是进行 Web Service 的开发
  \item 和 Java 类似，但优于Java，除支持垃圾自动回收等，还支持局部类泛型等
  \end{itemize}
}

% \section{C\#的基本语法}
\begin{frame}[fragile]
\frametitle{C\# 语言的语法}
\begin{itemize}
\item 与 C 族语言类似(C/C++/Java)
  \pause
\item 标识符区分大小，不能以数字开始
  \pause
\item 变量可以随时声明，用 ~new 关键字创建类的实例
\begin{lstlisting}
int    a = 10;
Circle b = new Circle();
\end{lstlisting}
  \pause
\item 注释有三种风格
\begin{lstlisting}
/* multi-line comments */
// single-line comments
/// <summary> XML comments </summary>
\end{lstlisting}

  \pause

\item  通过~XML~注释，可自动生成程序文档
  \cmd{csc /doc:doc.xml source.cs}

\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item 语法类似 C/C++/Java
  \item 同样的变量声明，创建类实例，如例子所示
  \end{itemize}
}


\begin{frame}[fragile]
\frametitle{C\# 语言的语法(续)}
\begin{itemize}
\item<1-| handout:1> 所有程序逻辑和数据必须包含在类型中，没有全局变量

\item<2-| handout:1> 可执行文件必须有一个 ~\texttt{Main()} 方法，并用 ~\texttt{static} 修饰

  \begin{uncoverenv}<2-| handout:1>
\begin{lstlisting}
using System;
class Hello {
  static void Main(){
    Console.WriteLine("Hello World!");
  }
}
\end{lstlisting}
  \end{uncoverenv}

\end{itemize}


\end{frame}
\section{基本类型}

\begin{frame}
\frametitle{基本数据类型  (\textit{Primitive Data Types})}
\begin{tabular}{l|l|l}
\hline
  C\#类型 & FCL 类型       & 说明 \\
\hline
  object  & System.Object  & 所有对象的基类型     \\
  string  & System.String  & Unicode 字符序列     \\
  bool    & System.Boolean & true 或 ~false       \\
  char    & System.Char    & 字符型，2 字节       \\
  byte    & System.Byte    & 单字节有符号整数     \\
  sbyte   & System.SByte   & 单字节无符号整数     \\
  short   & System.Int16   & 2 字节有符号整数     \\
  ushort  & System.UInt16  & 2 字节无符号整数     \\
  int     & System.Int32   & 4 字节有符号整数     \\
  uint    & System.UInt32  & 4 字节无符号整数     \\
  long    & System.Int65   & 8 字节有符号整数     \\
  ulong   & System.UInt64  & 8 字节无符号整数     \\
  float   & System.Single  & 单精度浮点数(4字节)  \\
  double  & System.Double  & 双精度浮点数(8字节)  \\
  decimal & System.Decimal & 高精度浮点数(16字节) \\
\end{tabular}
\end{frame}

\begin{frame}
\frametitle{简单数据类型(Primitive Data Types)}
\begin{itemize}
\item 字符串型：string
\item 布尔型~bool：值为~true~或~false 
\item 字符型~char：长度为 2 字节(Unicode字符) 
\item 整数型：\\byte, sbyte, short, ushort, int, uint, long, ulong 
\item 浮点型：float, double, decimal 
\item 枚举类型：enum
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item C\# 中有较丰富的数据类型
  \item 新的内置数据类型 string 和 bool，bool长度为 1 字节，值为 true/false
  \item 分别支持 1/2/4/8 字节长的整型
  \item 以及 4/8/16 字节长的浮点型
  \end{itemize}
}

\begin{frame}[fragile]
\frametitle{C\# 类型与~FCL 类型}
\begin{itemize}
\item C\# 的基本类型直接映射到 ~FCL 类型
\begin{lstlisting}
System.Int32 x = 100; // int x
int y = x;
\end{lstlisting}
\item 因此类型本身也由 ~FCL 提供了一些基本的成员和方法

\begin{lstlisting}
short smax = short.MaxValue;  //  32767
int   imin = int.MinValue;    // -2147483648

string s = "2372701";
int    v = int.Parse(s);

decimal z, y, pi = 3.14159265358979323846M;
y = decimal.Round(pi,3);        // 3.142
z = decimal.Remainder(pi,1.3M); // 0.54159265...

\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{数据的表示}

\begin{itemize}
\item bool 只能有 ~\lstinline|true| 和 ~\lstinline|false| 两个值
\item 数字的后缀
  \begin{itemize}
    \lstset{emph={[3]L,M,U,UL,F}}
  \item \lstinline|100, 100U, 100L, 100UL; // int, uint, long, ulong|
  \item \lstinline|2.12F, 2.12, 2.12M;     // float, double, decimal|
  \end{itemize}
\item char 类型表示 ~Unicode 字符 (\lstinline| char c;|)
  \begin{columns}
    \column{.35\textwidth}
\begin{lstlisting}
c = 'B';
c = (char) 66;
c = '\u5B57';
c = '\x0042';
c = '\t';
c = char.Parse("K");
\end{lstlisting}
    \column{.55\textwidth}
\begin{lstlisting}
string s = "123abcd?";
c = char.IsLetter(s,3);
c = char.IsNumber(s,3);
c = char.IsLower(s,0);
c = char.IsPunctuation(s,7);
c = char.IsLetterOrDigit(s,1);
\end{lstlisting}
  \end{columns}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{字符串}
% unicode 字符序列
\begin{itemize}
\item C\# 中基本的数据类型， Unicode 字符序列
\item 在堆中分配，但使用效果和值类型相似
\item 使用 ~``\texttt{@}'' 字符修饰，表示{\color<handout:0>{red!65!black}逐字串}(\textit{Verbatim String})
\begin{lstlisting}
string s1, s2;
s1 = "C:\\WINDOWS\\system32";
s2 = @"C:\WINDOWS\system32";

s1 = "Hello \nWorld!";
s2 = @"Hello
World!";

\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{字符串(续)}
\begin{itemize}
\item 通过 ~``\texttt{+}'' 可以直接连接串
\begin{lstlisting}
s1 = "Hello"; s2 = " World!";
s3 = s1 + s2 ;

s4 = "20/5 = " + 20/5;
\end{lstlisting}
  
  \CJKindent \small 但需要注意，字符串的连接会生成新的串，如果大量操作，会影响效率。

\item string 类型中提供的其他方法
  \begin{itemize}
    % Split(), 
  \item 抽取子串 {\color{red}TODO}
    % IndexOf(),
  \item 比较字符串 {\color{red}TODO}
    % CompareTo(),
  \item 转换大小写
    % ToLower(), ToUpper()
  \item 对象的 ToString() 方法
  \item 成员
    % Length, 
  \end{itemize}
\end{itemize}

\end{frame}

\begin{frame} \frametitle{\texttt{WriteLine} 方法的格式}

\CJKindent 

\end{frame}
\begin{frame}[fragile]
\frametitle{结构体类型}
\CJKindent 结构体是和类(class)相似的一种简单的封装构造，同样可以包含成员变量和方法。
\begin{lstlisting}[escapeinside=<>]
struct Point {
  int x,y;
  public Point(int X, int Y)
    { x=X;  y=Y;}
}
\end{lstlisting}
\begin{itemize}
\item 结构体不能定义无参数的构造函数，不能定义析构函数
\item 如果定义构造函数，必须为结构体中的每个字段赋值
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item 也支持 struct，和 class 类似
  \end{itemize}}

\begin{frame} 
\frametitle{枚举类型}

\end{frame}

\begin{frame}[fragile]
\frametitle{数组}
\begin{itemize}
\item 一维数组
\begin{lstlisting}[escapeinside=<>]
int[] x; // <声明一个数组变量>
int[] y = new int[4]; // <创建数组>
int[] z = new int[] {1,3,5}; // <初始化>

\end{lstlisting}
  
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{多维数组}
\begin{itemize}
\item 矩形多维数组
\begin{lstlisting}[escapeinside=<>,mathescape]
int[,] y = new int[4,3]; // $4\times3$ <的数组>

\end{lstlisting}
  
\item 锯齿形多维数组
\begin{lstlisting}[escapeinside=<>]
int[][] z = new int[2][];
     z[0] = new int[3]; // z[0]<长度为3>
     z[1] = new int[5]; // z[0]<长度为3>
//z[0]<只是数组变量；>z[0][0]<才是整数>

\end{lstlisting}
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item 数组的声明稍有不同，不过和 Java 类似
  \item int[]表示类型，需要创建实例
  \item int[,] 和 int[][]不同
  \end{itemize}
}

\begin{frame}[fragile]
\frametitle{溢出检查(checked和unchecked)}
\begin{itemize}
\item 进行溢出检查
  \lstset{emph={checked,unchecked}}
\begin{lstlisting}[escapeinside=<>]
int i = 1000000, j = 1000000;
int x = checked(i*j);
//<发生运行时异常：>System.OverflowException

\end{lstlisting}
  
\item 不进行溢出检查
\begin{lstlisting}[escapeinside=<>]
int i = 1000000, j = 1000000;
int x = unchecked(i*j);
//<无异常出现，但> x=-727379968

\end{lstlisting}
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{预处理指令}
% #define/#undef
% #if/#elif/#else/#endif
% #line
% #region/#endregion
% #error/#warning

% 命令行 csc /Define:XX hello.cs

\end{frame}
\section{流程控制}

\begin{frame}[fragile]
\frametitle{分支语句}
\begin{onlyenv}<1-2>
  \begin{itemize}
  \item if-else 语句
\begin{lstlisting}
  if (a>=b){
    x =  1;
  } else if (a<b) {
    x = -1;
  }
\end{lstlisting}
    \pause
  \item 判断条件的值必须是 bool 型的 true 或 false
\begin{lstlisting}[escapeinside=<>]
  int i = 1;
  if (i) { ... }
  // <编译错误：无法隐式的将~int~转为~bool>
\end{lstlisting}
  \end{itemize}
\end{onlyenv}

\begin{onlyenv}<3>
  \begin{itemize}
  \item switch 语句
  \end{itemize}
  \begin{columns}
    \column{.5\textwidth}
\begin{lstlisting}
int Score; string r;
switch(Score/10){
  case 10:
  case 9:  
    r = "A"; break;
  case 8:  
    r = "B"; break;
  ...
  default: 
    r = "E"; break;
}

\end{lstlisting}
    \column{.5\textwidth}
\begin{lstlisting}
int Score; string r;
switch(Score/10){
  case 10:
    r = "A+"; 
    goto case 9;
  case 9:  
    r = "A"; break;
  ...
  default: 
    r = "E"; break;
}

\end{lstlisting}
  \end{columns}
\end{onlyenv}
\end{frame}
\note{
  \begin{itemize}
  \item case 语句之间
  \item 如果语句为空，可以自动进入下一个 case 语句
  \item 如果不空必须显示使用 goto case xx; 语句
  \end{itemize}
}
\begin{frame}[fragile]
\frametitle{循环语句}
\begin{itemize}
\item while/do-while 循环
\begin{lstlisting}
while (condition) { ... }
do { ... } while (condition);
\end{lstlisting}
  \pause
\item for 循环
\begin{lstlisting}
for(int i=0; i<5; i++) { ... }
\end{lstlisting}
  \pause
\item foreach 循环
\begin{lstlisting}
string[] colors={"Red","Green","Blue"};
foreach (string x in colors) {
  Console.WriteLine(x);
}
\end{lstlisting}
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item foreach 和 VB 中的类似，用来对数组中的每个元素进行迭代
  \item 使用 foreach 可以省去使用索引变量的麻烦，也不用判断数组的长度
  \end{itemize}
}

\begin{frame}
\frametitle{跳转语句}
\begin{itemize}
\item break \\用来退出 while, do-while, for 和 foreach 循环以及 swich 分支语句等；
\item continue \\用来中断循环的当前迭代，并继续循环；
\item goto \\任意跳转；
\item return \\返回方法的调用；
\end{itemize}
\end{frame}

\section{异常}
\begin{frame}[fragile]
\frametitle{异常处理(try-catch-finally)}
捕捉和处理可能在运行时发生的错误的技术，常见的异常有整数溢出、下标越界、IO错误等。\pause
\begin{itemize}
\item try 监测异常的发生
\begin{lstlisting}
try { ... }
\end{lstlisting}
  \pause
\item catch 捕获并处理异常
\begin{lstlisting}[escapeinside=<>]
catch (SomeException e) { 
  // <处理> SomeException <类型的异常> e
}

\end{lstlisting}
  \pause
\item finally 确保必要操作一定会执行
\begin{lstlisting}
finally { ... }
\end{lstlisting}
\end{itemize}
\end{frame}

\note{
  \begin{itemize}
  \item 以一种优雅的方式处理错误
  \item 可以将正常代码和错误处理代码分开
  \end{itemize}}

\begin{frame}[fragile]
\frametitle{异常处理举例}
\begin{lstlisting}
// using System; using System.IO;
StreamWriter sw = null;
try {
  sw = new StreamWriter(
    new FileStream("T.txt",FileMode.Open));
  sw.WriteLine ("Hello World");           
}
catch (FileNotFoundException e) {
  Console.WriteLine("File "
               +e.FileName+" not found.");
}
catch (Exception e){ Console.WriteLine(e);}
finally { if (sw!=null)   sw.Close();     }

\end{lstlisting}
\end{frame}

\note{
  \begin{itemize}
  \item 例子中打开文件处可能发生错误，如文件不存在，或者不可读
  \item 当不存在时，在第一个catch处捕获，并处理
  \item 其他任何错误，都会被更通用的异常类型捕获
  \item finally保证，无论是否发生异常，此处代码都会被执行
  \end{itemize}}

% Local Variables: 
% mode: LaTeX
% TeX-master: "lesson-02.tex"
% TeX-header-end: "% End-Of-Header$"
% TeX-trailer-start: "% Start-Of-Trailer$"
% coding: gb2312-dos
% End:
