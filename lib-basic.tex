%% Slides for ".NET Programming" by Chunyu Wang <chunyu@hit.edu.cn> %%

\part{框架类库}
\begin{frame}
\frametitle{Outline}            % {C\# 的类}
\tableofcontents
\end{frame}

\section{集合}

\begin{frame}
\frametitle{集合~ System.Collections}

\begin{itemize}
\setlength{\itemsep}{8pt plus 1pt}
\item 集合，即一组对象~ (\textit{object})
\item .NET 提供了 ~Lists, Stacks, Queues, Hash Tables 等集合结构
\item 提供了对集合操作的接口，如枚举器、迭代器
\item System.Collections.Generic 提供了相应的泛型结构
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{ArrayList}
\begin{lstlisting}
using System;
using System.Collections;
public class SamplesArrayList  {
  public static void Main()  {

    ArrayList myAL = new ArrayList();
    myAL.Add("Hello");
    myAL.Add("World");
    myAL.Add("!");

    Console.WriteLine("Count:    {0}", myAL.Count);
    Console.WriteLine("Capacity: {0}", myAL.Capacity);
    foreach ( Object obj in myAL )
      Console.Write( "{0} ", obj );
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Stack}
\begin{lstlisting}
using System;
using System.Collections;
public class SamplesStack  {
  public static void Main()  {

    Stack myStack = new Stack();
    myStack.Push("Hello");
    myStack.Push("World!");
    myStack.Pop();

    Console.WriteLine( "Count: {0}", myStack.Count );
    Console.Write( "Values:" );
    foreach ( Object obj in myStack )
      Console.Write( " {0}", obj );
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{ICollection 接口}
ICollection 继承自~ IEnumerable，提供了基本的集合操作。
\begin{itemize}
\setlength{\itemsep}{8pt plus 1pt}
\item 特性
\begin{itemize}
\setlength{\itemsep}{6pt plus 1pt}
\item \texttt{int Count \{get;\} --- 当前集合中元素个数}
\item \texttt{object SyncRoot \{get;\} --- 用于多线程的同步}
\end{itemize}
\item 方法
\begin{itemize}
\item \texttt{void CopyTo(Array target, int startIdx)}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{IList 接口}
IList 接口继承自~ ICollection，提供了基于索引的操作方式。
\begin{itemize}
\item 索引器： \texttt{object this[int idx] \{ get; set; \}}
\begin{lstlisting}
ArrayList myAL = new ArrayList();
myAL[0] = "Hello"; myAL[1] = 123;
\end{lstlisting}
\item 特性
\begin{itemize}
\item \texttt{bool IsFixedSize \{ get; \}}
\item \texttt{bool IsReadOnly \{ get; \}}
\end{itemize}
\item 方法
\begin{itemize}
\item \texttt{int Add(object obj)} --- 添加元素
\item \texttt{void Clear()} --- 删除所有元素
\item \texttt{void Remove(object obj)} --- 删除第一个 ~\texttt{obj}
\item \texttt{Contains, IndexOf, Insert, RemoveAt}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{IDictionary 接口}
\CJKindent IDictionary 接口继承自~ ICollection，提供了基于键~ (\textit{key}) 的索引方式。
\begin{itemize}
\item 索引器：
  \begin{itemize}
  \item \texttt{object this[object key] \{ get; set; \}}
  \end{itemize}
\item 特性
\begin{itemize}
\item \texttt{bool IsFixedSize \{ get; \}}
\item \texttt{bool IsReadOnly \{ get; \}}
\item \texttt{ICollection Keys \{ get; \}} --- 返回所有键
\item \texttt{ICollection Values \{ get; \}} --- 返回所有值
\end{itemize}
\item 方法
\begin{itemize}
\item \texttt{void Add(object k, object v)}
\item \texttt{Clear, Contains, Remove, ...}
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{ArrayList 类}
ArrayList 实现了 ~ICollection, IList, IEnumerable, ICloneable 接口。
\begin{itemize}
\item 构造函数
\begin{itemize}
\item \texttt{public ArrayList()}
\item \texttt{public ArrayList(ICollection c)}
\item \texttt{public ArrayList(int \textit{capacity})}
\end{itemize}
\item 特性
  \begin{itemize}
  \item \texttt{public virtual int Capacity \{ get; set; \}}
  \end{itemize}
\item 方法
  \begin{itemize}
  \item \texttt{public virtual void Sort()}
  \item \texttt{public virtual void Sort(IComparer \textit{comp})}
  \item \href{http://msdn2.microsoft.com/en-us/library/system.collections.arraylist_members.aspx}{\beamergotobutton{参考 ~MSDN}}
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Hashtable 类}

\CJKindent Hash table 使用~ \textit{hasing} 技术存储数据。将键转换
为~\textit{Hash code}，用于数据的索引，决定数据的存储位置。

\begin{itemize}
\item 键转换为 ~Hash code 的过程是自动的
\item 访问时也只需使用键本身，不使用 ~Hash code
\item 使用 ~Hash table 可以提高字典的访问效率
\end{itemize}

\CJKindent Hashtable 实现了~ IDictionary, ICollection, IEnumerable,
ISerializable, IDeserializationCallback, 和~ICloneable 接口。
\end{frame}

\begin{frame}
\frametitle{Hashtable 的成员}
\begin{itemize}
\item 构造函数
\begin{itemize}
\item \small \texttt{public Hashtable()}
\item \small \texttt{public Hashtable(IDictionary c)}
\item \small \texttt{public Hashtable(int capacity)}
\item \small \texttt{public Hashtable(int capacity, float fillRatio)}
\end{itemize}
\item 特性
\begin{itemize}
\item \small \texttt{public virtual ICollection Keys \{ get; \}}
\item \small \texttt{public virtual ICollection Values \{ get; \}}
\end{itemize}
\item 方法
\begin{itemize}
\item \texttt{public virtual bool ContainsKey(object k)}
\item \texttt{public virtual bool ContainsValue(object v)}
\item \dots
\end{itemize}
\end{itemize}

\end{frame}

\begin{frame}[fragile,plain]
\frametitle{Hashtable 示例}
\begin{lstlisting}
using System;
using System.Collections;

class HashtableDemo {
  public static void Main() {
    Hashtable ht = new Hashtable();

    ht.Add("house", "Dwelling");
    ht.Add("car", "Means of transport");
    ht.Add("book", "Collection of printed words");
    ht.Add("apple", "Edible fruit");

    ht["tractor"] = "Farm implement";

    ICollection c = ht.Keys;

    foreach(string str in c)
      Console.WriteLine(str + ": " + ht[str]);
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{其他集合类}
\begin{itemize}
\setlength{\itemsep}{8pt plus 1pt}
\item \texttt{SortedList} --- 根据键值按循序排列的列表 \par
\CJKindent \small 实现了~ IDictionary, ICollection, IEnumerable 接口。
\item \texttt{Stack}      --- 栈 \par
\CJKindent \small 实现了~ ICollection, IEnumerable接口。
\begin{itemize}
\item Posh(), Pop(), Peek(), Contains() \dots
\end{itemize}
\item \texttt{Queue}      --- 队列 \par
\CJKindent \small 实现了~ ICollection, IEnumerable 接口。
\begin{itemize}
\item Dequeue(), Enqueue(), Peek(), Contains() \dots
\end{itemize}
\item \texttt{BitArray}   --- 按位~ (\textit{bit}) 存储 \par
\CJKindent \small 实现了~ ICollection, IEnumerable 接口。
\begin{itemize}
\item 多种构造函数，便于从其他数据生成
\item And(), Or(), Not(), Xor(), Set() \dots
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{专用集合}
\begin{itemize}
\setlength{\itemsep}{5pt plus 1pt}
\item System.Collections.Specialized 中定义了一些专门的集合类
\item 在特定类型的上有一定的优化
\bigskip
\item \texttt{CollectionsUtil} 创建忽略字符串大小写的集合
\item \texttt{ListDictionary} 使用单链接列表实现~ IDictionary
\item \texttt{NameValueCollection} 关联 ~String 键和~ Object 值的集合
\item \texttt{OrderedDictionary} 根据索引排序的字典
\item \texttt{StringCollection} 字符串集合
\item \texttt{StringDictionary} 将键和值强类型化为字符串的哈希表
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{泛型接口}
\begin{itemize}
\item ICollection$<$T$>$ 操作泛型集合
\item IComparer$<$T$>$ 比较两个对象
\item IDictionary$<$TK, TV$>$ 键/值对的泛型集合
\item IEnumerable$<$T$>$ 泛型枚举接口
\item IEnumerator$<$T$>$ 泛型集合上迭代接口
\item IEqualityComparer$<$T$>$ 对象的相等比较
\item IList$<$T$>$ 按照索引单独访问
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{泛型集合类}
\begin{itemize}
\item List$<$T$>$ 泛型列表
\item Queue$<$T$>$ 泛型队列
\item Stack$<$T$>$ 泛型栈
\item LinkedList$<$T$>$ 泛型双向链
\begin{lstlisting}
public LinkedList()
public LinkedList(IEnumerable<T> c)

public LinkedListNode<T> Next { get; }
public LinkedListNode<T> Previous { get; }
public LinkedList<T> List { get; }
public T Value { get; set; }

public int Count { get; }
public LinkedListNode<T> First { get; }
public LinkedListNode<T> Last { get; }
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{IEnumerator 和~ IEnumerable 接口}
主要用于 ~\texttt{foreach} 循环。

IEnumerator:
\begin{itemize}
\item \texttt{object Current \{get;\}} --- 返回当前对象
\item \texttt{bool MoveNext();} --- 下移一个位置
\item \texttt{void ReSet();} --- 复位
\end{itemize}
IEnumerable:
\begin{itemize}
\item \texttt{IEnumerator GetEnumerator();}
\end{itemize}
示例：IEnumerable.cs \attachfile[description=IEnumerable]{code/IEnumerable.cs}
\end{frame}

\begin{frame}[fragile]
\frametitle{迭代器 (\textit{Iterators})}
\begin{itemize}
\item 用于简化 ~IEnumerator 和 ~IEnumerable
\item 使用 ~\texttt{yield return} 返回 ~IEnumerable 对象
\end{itemize}

\lstset{emph={yield}}
\begin{lstlisting}
using System.Collections;
class MyClass {
  char[] chrs = { 'A', 'B', 'C', 'D' };

  public IEnumerator GetEnumerator() {
    foreach(char ch in chrs)
      yield return ch;
  }
}
...
  public static void Main() {
    MyClass mc = new MyClass();

    foreach(char ch in mc)
      System.Console.Write(ch + " ");
  }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{多条 ~\texttt{yield} 语句}
\CJKindent 关键字 ~\texttt{yield} 自动构造 ~IEnumerator 对象，可使用多次：
\begin{lstlisting}
using System;
using System.Collections;
class MyClass {
  ...
  public IEnumerator GetEnumerator() {
    yield return 'A';     yield return 'B';
    yield return 'C';     yield return 'D';
  }
}
...
  public static void Main() {
    MyClass mc = new MyClass();

    foreach(char ch in mc)
      Console.Write(ch + " ");
  }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{终止迭代器}
使用 ~\texttt{yield break} 可以终止迭代器继续进行
\begin{lstlisting}
...
  public IEnumerator GetEnumerator() {
    for(int i=0; i < 26; i++) {
      if(i == 5) yield break; // stop iterator early
      yield return (char) (ch + i);
    }
  }
...

    foreach(char ch in mc)
      Console.Write(ch + " ");
    // output: "A B C D E "
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{命名迭代器}
通过定义返回 ~IEnumerable 类型的方法来实现：
\begin{lstlisting}
public class List
{
  public static IEnumerable Power(int number, int exponent)
  { int counter = 0;
    int result = 1;
    while (counter++ < exponent)
    { result = result * number;
      yield return result;
    }
  }
  static void Main()
  { foreach (int i in Power(2, 8))
    {
        Console.Write("{0} ", i);
    }
  }
}
\end{lstlisting}
\end{frame}

\section{文本处理}

\begin{frame}[fragile]
\frametitle{StringBuilder 类}
可变字符串类~ StringBuilder：
\begin{lstlisting}
public sealed class StringBuilder {
  public method StringBuilder();  
  public method StringBuilder(int capacity);  
  public method StringBuilder(int capacity, int maxCapacity);  
  
  public method StringBuilder(string value);  
  public method StringBuilder(string value, int capacity);  
}
\end{lstlisting}
\begin{itemize}
\item capacity --- 串的长度
\item maxCapicity --- 串的最大长度
\item 如果没有指定最大长度，会自动成倍增加
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{StringBuilder 的成员}
\begin{itemize}
\item 成员特性
\end{itemize}
\begin{lstlisting}
  public field int Capacity{set; get; } 
  public field int Length{set; get; } 
  public field int MaxCapacity{get; } 
\end{lstlisting}
\begin{itemize}
\item 成员方法
\begin{itemize}
\item Append()
\item AppendFormat()
\item Insert()
\item Replace()
\item Remove()
\end{itemize}
\end{itemize}
\end{frame}


% \begin{frame}
% \frametitle{文本的编码}

% \end{frame}

% Cookbook Regular Expressions, C# in a Nutshell

\begin{frame}
\frametitle{正则表达式}
\begin{itemize}
\setlength{\itemsep}{8pt plus 1pt}
\item 位于 ~System.Text.RegularExpressions 命名空间
\item 常用的类
\begin{itemize}
\setlength{\itemsep}{6pt plus 1pt}
\item Regex  --- 用于构造正则表达式对象，也有一些静态方法
\item Match, MatchCollection \\
  使用正则表达式进行匹配的结果，或结果集合
\item Group, GroupCollection \\
  正则表达式的分组匹配，即正则表达式的一部分
\item Capture, CaptureCollection \\
  分组的匹配中，由分组匹配的所有捕获
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{正则表达式示例}
\begin{lstlisting}
using System;
using System.Text.RegularExpressions;
public class List
{
  static void Main()
  {
    string s = @"<img\s+src=""(.*?)"">";
    Regex r = new Regex (s, RegexOptions.IgnoreCase) ;
    Match m = r.Match("<IMG src=\"http://abc.cn/a.jpg\">");

    for (int i=0; i<m.Groups.Count; i++)
      Console.WriteLine (m.Groups[i]);

    Console.ReadLine();

  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{特殊字符}
\begin{tabular}{c|l}
\hline
字符 & 说明 \\
\hline
\verb|.| & 任何字符，除换行符外 \\
\verb|* + ?| & 前一部分的重复次数，尽可能多匹配 (\textit{greedy}) \\
\verb|\| & 转义字符 \\
\verb|[|\dots\verb|]| & 字符集合，表示其中的任意字符 \\
\verb|(|\dots\verb|)| & 分组，用于重复、引用等 \\
\verb|{|n,m\verb|}| & 表示匹配次数 \\
\verb|$| & 行尾空串 \\
\verb|^| & 行首空串 \\
\hline
\verb|\b| & 单词边界上的空串 \\
\verb|\s| & 匹配任何空白字符 \\
\verb|\w| & 匹配任何单词字符 \\
\verb|\d| & 匹配数字 \\
\verb|\cC| & 匹配控制字符 ~Ctrl-C \\
\hline
\end{tabular}
\end{frame}

\begin{frame}[fragile]
\frametitle{分组及引用}
\begin{tabular}{c|l}
\hline
分组 & 使用方式 \\
\hline
\verb|(|\dots\verb|)| & 通过数字 ~\verb|\N| 引用 \\
  & 例如 ~\verb|(\w)\s+\1| \\
\verb|(?<|\textit{name}\verb|>|\dots\verb|)| & 通过名字 ~\verb|\k<|\textit{name}\verb|>| 引用 \\
  & 例如 \verb|(?<word>\w)\s+\k<word>| \\
\hline
\hline
替换方式 & 说明 \\
\hline
\verb|$|\textit{N} & 按组号替换 \\
\verb|${|\textit{name}\verb|}| & 按组名字替换 \\
\hline
\end{tabular}
\medskip
\begin{lstlisting}[escapeinside='']
String ChangeDateFormat(String input)
{ // '将 ~mm/dd/yyyy 替换为 ~yyyy-mm-dd 格式'
return Regex.Replace(input,
@"\b(?<month>\d{1,2})/(?<day>\d{1,2})/(?<year>\d{2,4})\b",
"${year}-${month}-${day}");
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{正则表达式示例}
\begin{itemize}
\item 交换前两个单词
\begin{lstlisting}
string t1 = "the quick brown fox";
string p1 = @"(\S+)(\s+)(\S+)";
Regex x1 = new Regex(p1);
string r1 = x1.Replace(t1, "$3$2$1", 1);
\end{lstlisting}
\item 匹配~ "keyword = value" 模式
\begin{lstlisting}
string t2 = "myval = 3";
string p2 = @"(\w+)\s*=\s*(.*)\s*$";
Match m2 = Regex.Match(t2, p2);
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{正则表达式示例}
\begin{itemize}
\item 匹配至少 ~40 字符的行
\begin{lstlisting}
string t3 = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
string p3 = ".{40,}";
Match m3 = Regex.Match(t3, p3);
\end{lstlisting}
\item 替换用户名
\begin{lstlisting}
string t4 =
    @"C:\Documents and Settings\user1\Desktop";
string r4 = Regex.Replace(t4,
                          @"\\user1\\",
                          @"\\user2\\");
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{正则表达式示例}
\begin{itemize}
\item 查找所有字母大写的单词
\begin{lstlisting}
string t5 = "This IS a Test OF ALL Caps";
string p5 = @"(\b[^\Wa-z0-9_]+\b)";
MatchCollection mc5 = Regex.Matches(t5, p5);
\end{lstlisting}
\item 查找所有首字母大写的单词
\begin{lstlisting}
string t6 = "This is A Test of Initial Caps";
string p6 = @"(\b[^\Wa-z0-9_][^\WA-Z0-9_]*\b)";
MatchCollection mc6 = Regex.Matches(t6, p6);
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{正则表达式示例}
\begin{itemize}
\item 查找 ~HTML 中的连接
\end{itemize}
\begin{lstlisting}
string t7 = @"
<html>
<a href=""http://a.b.c/news/first.htm"">first tag text</a>
<a href=""http://a.b.c/news/next.htm"">next tag text</a>
</html>
";
string p7 = @"<A[^>]*?HREF\s*=\s*[""']?"
  + @"([^'"" >]+?)[ '""]?>";
MatchCollection mc7 = 
    Regex.Matches(t7, p7, RegexOptions.Singleline);
\end{lstlisting}
\end{frame}

% Local Variables:
% mode: LaTeX
% TeX-master: "part-04.tex"
% TeX-header-end: "% End-of-Header$"
% TeX-trailer-start: "% Start-of-Trailer$"
% coding: gb2312-dos
% End:
