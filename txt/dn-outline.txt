#  -*- org -*- 

NET对用户和开发人员的重要意义

您的网上寻呼机在响个不停；卖方已经接受了您的还价！您频繁访问MoneyCentral4，挪出1000股MSFT股份放到您的支票帐户中。确认出售后，您接受了佣金，随后便将预付款划入了Chicago Title第三方帐户中。Bob发来消息：“一切OK了!”

根据天气预报，星期六将是大晴天，气温为华氏75度。家居电脑报告说“主人，Tammy和Joe打算外出游玩。出发时间定为下午1点，已预定了晚餐，同时将Sandra交托给临时保姆。”上述所有信息，可通过点击运动员俱乐部处的固定自行车图标得到。

Microsoft .NET的策略是将互联网本身作为构建新一代操作系统的基础，对互联网和操作系统的设计思想进行合理延伸。这样，开发人员必将创建出摆脱设备硬件束缚的应用程序，以便轻松实现互联网连接。Microsoft .NET无疑是当今计算机技术通向计算时代的一个非常重要的里程碑。

.NET的核心组件

    * ・ 一组用于创建互联网操作系统的构建块，其中包括Passport.NET（用于用户认证）以及用于文件存储的服务、用户首选项管理、日历管理以及众多的其它任务
    * ・ 构建和管理新一代服务的基本结构和工具，包括Visual Studio.NET、.NET企业服务器、.NET框架和Windows.NET
    * ・ 能够启用新型智能互联网设备的.NET设备软件
    * ・ .NET用户体验

.NET为何如此意义重大？

.NET对最终用户来说非常重要，因为计算机的功能将会得到大幅度提升，同时计算机操作也会变得非常简单。特别地，用户将完全摆脱人为的硬件束缚：用户可以自由冲浪于互联网的多维时空，而不是束缚在便携式电脑的方寸空间――可通过任何桌面系统、任何便携式电脑、任何移动电话或PDA进行访问，并可对其进行跨应用程序的集成。

.NET可使用户轻松进行互联网连接，并轻松完成那些在当今看来十分费时而且费力的事务，它们往往要求用户进行数据重输入并需运行几个小时才能完成。通过将多项安全数据流合并到单一的用户界面（或者甚至是可编程决策引擎），.NET架构将用户从充斥于当今Web的数据竖井的束缚中解脱出来。用户可以自由访问、自由查看、自由使用他们的数据。

.NET对开发人员来说也十分重要，因为它不但会改变开发人员的开发应用程序的方式，而且使得开发人员能创建出全新的各种应用程序。新型开发范例的核心是 Web服务这个概念的引入。Web服务是一种通过简单对象访问协议(SOAP)，在互联网上展露其功能性的、极为公开的服务。SOAP是一种基于可扩展标记语言(XML)制定的协议。

Web服务崭露头角

在过去，开发人员通过集成本地系统服务来构建应用程序。在这种模型下，开发人员可以访问丰富的开发资源并能严格控制应用程序的行为。

如今，开发人员已在很大程度上挣脱了这种模型的束缚，致力于构建具有复杂结构的n层化系统，这种系统能将网络上众多的应用程序一并进行集成，大大提升了应用程序的价值。这样，开发人员便可把精力集中在充分挖掘软件独特的商业价值，而不是构建基本结构上。可喜的局面将应运而生：软件投放市场的时间大大缩短、开发人员的编程效率明显提高，最终把质量上乘的软件呈现给用户。

我们正在进入一个崭新的计算时代――一个由互联网（尤其是Internet核心技术XML）实现的时代。利用XML，能够创建出可供任何人从任何地方使用的、功能非常强大的应用程序。它极大地拓展了应用程序的功能，并实现了软件的动态提供。在这种情况下，软件已不完全指那些从光盘进行安装的程序，而是演变成了一种服务――类似于ID调用程序或按收看次数进行收费的电视――人们可通过通信媒体订购的服务。

n层计算技术具有能够大幅度提高生产力、紧密耦合的特点，而Web概念具有面向消息、松散耦合的特点，我们将二者有机地糅合在一起，实现了上述构想。我们将这种计算风格称为Web服务，它的出现标志着人类已经迈入应用程序开发技术的新纪元。Web服务是一种应用程序，它可以通过编程并使用标准的 Internet协议，像超文本传输协议(HTTP)和XML，将功能展示在互联网和企业内部网上。还可将Web服务视作Web上的组件编程。

从理论上讲，开发人员可通过调用Web应用编程接口(API)，将Web服务集成到应用程序中。其调用方法与调用本地服务类似，不同的是Web API调用可通过互联网发送给位于远程系统中的某一服务。例如，MicrosoftPassport(Passport)服务使得开发人员能够对应用程序进行认证。通过对Passport服务编程，开发人员可以充分利用Passport的基本结构，通过运行Passport来维护用户数据库，以确保其正常运行、定期备份等等。

.NET正是根据这种Web服务原则而创建的，微软目前正着手提供这个基本结构，以便通过.NET平台的每一部分来实现这种新型的Web服务。而 Visual Studio.NET、.NET框架、Windows.NET和.NET企业服务器，正是为进行基于Web服务模型的应用程序开发而度身定做的新一代开发工具和基本结构。.NET构建块服务、新增的.NET设备支持以及即将到来的.NET用户体验，将为人们彻底攻克这一难题划上一个圆满的句号，使人们能够充分利用Web服务模型，如愿以偿地开发出新一代应用程序。 


Microsoft .NET 将从根本上改变我们考虑和使用计算设备的方式。当前，服务器和客户端
桌面这两个概念是计算技术的最重要的概念。Microsoft .NET 将此模型扩展为松耦合服务
的丰富的、分布式计算范例。不管是在服务器、PC、掌上电脑还是在其他智能设备上，只
要是最适于进行处理，就会进行处理，而不必按照传统方式对桌面和服务器加以区分。这
是新一代智能设备的智能计算。

Microsoft .NET 计算模型以不同方式影响企业、个人和开发人员。对于个人：这些变化将
产生极其个性化的、集成的计算体验。对于企业和开发人员：它将改变企业和开发人员生
成软件和销售产品的方式，使 IT 成为企业成功的重要因素并引入新的业务模式。

尽管 Microsoft .NET 在计算技术领域带来了一些根本性变化，但是很多内容仍然保持不变：

    * 个人在 .NET 体验中仍将使用他们所熟悉的界面，如 Microsoft Office。这减少了
      重新培训的费用，意味着个人可以立即使用支持 .NET 的软件。

    * 硬件仍将运行一些操作系统，如 Microsoft Windows、UNIX、Windows CE 和
      PalmOS。实际上，.NET 在降低开发负担的同时增加了软件可以运行的平台数。因为
      XML Web services 只通过 XML 与设备进行通讯，所以任何智能设备都可以使用
      XML Web services。

    * 开发人员仍将使用他们首选的编程语言。借助 .NET 框架的公共语言运行库，.NET
      平台使各种 XML Web services 可以交互操作，而不管其源语言的不同。
      Microsoft .NET 体验同样对源语言不置可否，您可以通过使用 Microsoft Visual
      Basic、Java，甚至是 COBOL 编写的 XML Web services 产生这些体验。这种中立
      性意味着无须为了利用 .NET 平台而丢弃和替换现有成果。

    * 无需替换旧式系统。某些 Microsoft .NET 产品是为了将现有成果轻松地集成到新
      的 .NET XML Web services 和 .NET 体验中而专门设计的。例如，Microsoft
      Host Integration Server 简化对大型机的访问；Microsoft BizTalk Server 管理
      业务流程的编排，包括对现有的系统和数据格式的处理，同时进行到 XML 的必需的
      自动化数据转换。

因此，这一下一代分布式计算技术建立在当前这一代计算技术的基础之上。正如我们所知
道的，Microsoft .NET 并不是软件应用程序的整批替换，而是将协作和互操作性的好处带
给我们现有的技术“孤岛”的自然演变。


* 定义 .NET 的最简单方法

Sanjay Parthasarathy，平台战略副总裁，Microsoft Corporation
2000年 12 月 21 日

** 分布式计算

定义 .NET 最好的方式就是想一想 .NET 要做什么。Microsoft 认为向分布式计算的转变
正在悄悄地进行着。在过去的几年中，人们一直在铺设宽带电缆，使带宽的限制比过去要
小得多。根据摩尔定律效应，每 18 个月处理能力翻一番，价格降低一半，现在您首次可
以选择进行真正的分布式计算：因为带宽已经不那么昂贵，您可以在任何最佳地点进行处
理。

当今已经有很多这种分布式应用程序的例子。Napster 就是一个使用胖客户端与计算机群
集中的目录服务进行对话的应用程序，它把网络上的所有参与的计算机都当作服务器。另
一个分布式应用程序的例子是即时消息，胖客户端与计算机群集中一个伙伴列表对话，同
时还可以与网络中的其他胖客户端 - Instant Messenger 和 Windows 进行通信。

因此，.NET 的目的正是要加速产生下一代分布式计算的过程。

** 三个杠杆

我们认为可以拉动三个杠杆，以使下一代分布式计算尽可能快地发生。

  + Web 服务：第一个杠杆是一切都要成为 Web 服务。这适用于网络中的两种东西：软件
    和资源（如存储）。

  + 聚合与集成：第二个需要拉动的杠杆是，一旦您拥有了这些 Web 服务，就需要以一种
    非常简单和容易的方式将它们聚合与集成起来。

  + 简单而令人神往的用户体验：加速分布式计算的第三个杠杆是，需要有简单和令人神
    往的消费者或者最终用户体验。

因此我们认为这三个杠杆是加速向分布式计算转移的必要条件：

  * 一切都要成为 Web 服务；
  * 聚合与集成 Web 服务的能力；
  * 向最终用户提供简单而令人神往的体验的能力。

.NET 的目的正是致力于拉动这些杠杆，以加速向分布式计算的转移，为了正确地拉动这些
杠杆，我们正在做五项工作。

** 分五部分构建 .NET

*** 开发工具

我们做的第一项工作是：通过 .NET 框架和 Visual Studio 工具集，使编写 Web 服务尽
可能简单方便。我们认为，用于编写 Web 服务最好、最方便、最快并且最节约的方法是使
用 .NET 框架和 Visual Studio .NET 开发工具。

*** 服务器

我们做的第二项工作是：真正致力于 Web 服务聚合与集成，这恰恰是我们的 .NET 服务器
家族的用武之地。我们认为，这些服务器是用于聚合与集成 Web 服务最好、最简单、最方
便、最节约的方法。

可以从两个方面看待这些服务器。大家熟悉和喜爱的一组服务器是 Windows 2000、SQL
Server 2000、Exchange 2000，XML 管线内置于其核心。而 XML，正如您所知，可能是最
简单最大众化的集成 Web 服务的方法。第二类服务器是我们构建的专门服务器，如
BizTalk Server，它们提供更高级别和更灵活的聚合与集成。以 BizTalk Server 2000 为
例，它内置了一种叫作 XLANG 的语言，通过该语言您可以定义过程流、事务流和协定，也
可以跨异类环境进行相当深层次的集成。这就是 .NET 的第二部分：用以加速 Web 服务聚
合与集成的服务器集。

*** 基础服务

我们的第三项工作是：使最终消费者的体验简单而令人神往，为此我们正在构建一个
.NET 构造块服务集。几乎每个人，每当他遇到多个站点和多个应用程序时，都遇到过这样
的情况：需要登录这些站点和应用程序；我们正在创建一个诸如标识、通知和系统化存储
之类的小服务集，利用这些服务，消费者和用户从一个服务转向另一个服务，从一个应用
程序转到另一个应用程序，甚至从一种环境转向另一个环境都将非常容易。这种简单性在
分布式计算的世界里是绝对必要的。

这些 .NET 构造块服务对开发人员也有巨大的益处：它们与以前的 Windows 中的内存管理
器和文件系统非常相似，当人们编写应用程序时，不需要每次都把内存管理器和文件系统
复制一遍。我们相信，开发人员将喜欢这些服务集成到计算机群集中，而且它们得到保证，
因此他们可以将精力集中投入到可以大大增值的事情上去。.NET 构造块服务是 .NET 的第
三部分。

*** 设备

第四部分致力于最终用户的体验，通过一套我们正在创建的客户端和设备软件，将特别带
给用户令人神往的体验。首先，.NET 假设您拥有了一个设备家族，我们正是要创建许多设
备软件，以使人们可以使用相互取长补短的设备家族。我们将在设备软件中做一些有趣的
事情，以使您尽可能体验到令人神往的效果。一方面，您将拥有我们为游戏机创建的设备
软件，另一方面，您也将拥有我们为 PC 创建的设备软件，同时我们还致力于创建用于从
电话到 PDA 到其他如掌上 PC 之类的各种设备的软件。

*** 用户体验

在拉动简单而令人神往的用户体验这一杠杆方面，我们的最后一项工作，是正在实实在在
地创建一些非常有针对性的用户体验，把 Web 服务集合到一起，并且集成很多功能，以提
供非常有针对性的体验。我们正在创建

    * 面向消费者的 MSN
    * 面向小型企业的 bCentral
    * 面向知识工作者的 Office
    * 面向开发人员的 Visual Studio .NET。

*** .NET 平台

总而言之，这五部分就是 .NET 的全部内容。您已经了解了

    * .NET 框架和 Visual Studio .NET 工具；
    * 服务器；
    * .NET 构造块服务；
    * 设备软件；
    * 有针对性的用户体验。

我把前四者组合到一起称之为 .NET 平台，而最后一个则是建在该平台之上的应用。

** 小结

请您用 1-3-5 公式来看待 .NET。

.NET 要做什么？它要加速向分布式计算的转移。

.NET 要做什么？它要拉动三个杠杆，分别是

    * 一切都要成为 Web 服务；
    * 聚合与集成 Web 服务以及
    * 提供简单而令人神往的用户体验。

Microsoft 正在做哪些与 .NET 有关的工作？针对这些问题我们正在做五项工作：

    * 工具，
    * 服务器，
    * .NET 构造块服务，
    * 设备软件，以及
    * 用户体验。


* Microsoft .NET Framework安全概述

本文概述了微软.NET Framework安全结构，包括基于证据的安全，基于角色的安全，认证
和授权的概念，以及隔离存储，密码加密和扩展性。本文还概述了.NET Framework安全策
略带给开发人员，管理员和最终用户的主要好处。本文假定读者已经基本熟悉了.NET
Framework通用语言运行时和管理代码的概念。讲座的主题包括：

    * 引言
    * Microsoft .NET Framework安全性构件
    * 如何指定安全性
    * 总结 


** 引言

目前的安全问题

在今天的软件环境中，应用程序的来源很多，它们执行很多任务。对应用程序代码的信任
是一个主要需求，因为我们谁也不想软件或信息遭到破坏。给予许可的安全策略不会允许
对敏感信息的不适当的访问，或将本地机器暴露给恶意的程序或甚至是有平常错误的代码。

过去，安全结构提供了基于用户帐号的隔离和访问控制--在这些限制内给予代码完全访问
权，并假定由特定用户可运行的代码具有相同的信任度。不幸的是，如果所有程序都代表
某用户运行，根据用户对代码的隔离对于保护一个程序不被其它用户使用是不够的。另一
种情况，不能被完全信任的代码经常被转移到“沙箱”模型中执行，在此代码运行于隔离
环境，而不会访问大部分的服务。

对今天应用程序的成功的安全解决方案必须能强化两个安全模型间的平衡。它必须提供对
资源的访问，以便以完成有用的工作，它需要对应用程序的安全性作细致的控制以确保代
码被识别，检测，并给予合适的安全级别。.NET Framework就提供了一个这样的安全模型。

Microsoft .NET Framework安全解决方案

.NET Framework安全解决方案基于管理代码的概念，以及由通用语言运行时（CLR）加强的
安全规则。大部分管理代码需要进行验证以确保类型安全及预先定义好的其它属性的行为
的安全。例如，在验证的代码中，声明为接收4字节值的访问将拒绝提供8字节参数的调用，
因为不是类型安全的。验证过程还确保了执行流只传送到已知的位置，如方法入口点--这
个过程去除了跳转到任意位置执行的能力。

验证将阻止不是类型安全的代码执行，在它们引起破坏前捕获很多常见的编程错误。通常
的弱点--如缓存溢出，对任意内存或没有初始化的内存的读取，对控件的随意传送--都不
再可能出现。这将使最终用户受益，因为在他们执行代码前对其进行检查。这也有益于开
发人员，他们会发现很多常见错误（过去一直在困绕前开发）现在可以查明，并能阻止它
们引起破坏。

CLR也能使非管理代码运行，但非管理代码不能从这些安全措施中受益。特殊的许可与对非
管理代码的调用能力相关，一个强大的安全策略能确保这些许可被恰当地给予。经过很长
时间后，非管理代码到管理代码的移植将减少对非管理代码的调用频率。


** 微软.NET Framework安全机制的构件

基于证据的安全

.NET Framework引入了“基于证据的安全”的概念。在本质上，它是对安全策略暴露出来问题的解答：

    * 组合从哪个站点获得？
      组合是.NET Framework应用程序的构件。它们组成了部署，版本控制，重用，激活作用域，安全认证的基本单元。应用程序的组合是从网站上下载到客户端的。
    * 组合是从哪个URL获得的？
      安全策略需要明确的地址，而组合是从这个地址下载的。
    * 组合是从哪个区获得的？
      区是基于代码的位置，对安全标准，如 Internet, intranet和本机等等，的描述。
    * 组合的强名(strong name）是什么？
      强名是由组合的创建者提供了密码强化后的标识符。尽管它没有提供对创建者的任何证明，但它唯一标识了组合，确保了组合没有被破坏过。 

根据对这些问题的回答，及其它证据，安全策略可以对赋予组合垢合适许可进行计算。从多种来源可以得到证据，包括CLR，浏览器，微软ASP.NET，及外壳--这依赖于代码的来源。

策略驱动的信任模型使用代码证据
当组合被调入内存进，CLR策略系统通过收集组合的证据并在策略环境中对证据进行计算，从而决定赋予组合什么样的许可权。CLR策略系统然后根据评估过的证据和组合作出的许可请求给予组合一组许可。只有在组合被给予了一组最少的许可后，或组合根本不需要许可权，组合的创建者才能知道组合正确运行。通过一个或多个对特定许可的请求，这样的附加需求可以被传送室策略系统。

根据许可请求的类型，策略系统可以进一步限制给予组合的许可（删除不必要的许可）或甚至拒绝将组合装入内存（如果运行组合所需的最小许可没有被策略给予）。在不存在任何许可请求的情况下，组合永远不会被给予多于策略系统将会给予的许可权限，请求只是进一步限制得到的许可。

安全策略包含了许多代码组，这些组包含了根据证据应给予的许可权。代码组描述的许可可提供给从特定的安全区域获得的组合，或提供给由特定发行商签名过的组合，等等。尽管随CLR发行了一组默认的代码组（及相关许可），但管理员可以对这些 CLR安全的进行定置，以适合他们的特殊需求。记住，通过定义与证据相关的代码组，任何东西都可以作为证据提交，只要安全策略可以使用它。

创建许可的的过程涉及到对证据的评估，以确定代码组适用于哪个等级：企业，机器，和用户。策略按上面顺序对这三个等级进行评估，然后创建交插了三个等级的许可设置。管理员可以将任何一个策略等级标记为终结（final），这样做应付阻止在其它等级上对策略做进一步评估。例如，管理员可以在机器级别上对组合终止策略，这样就会阻止用户级策略对该组合的应用。

一旦策略完成，许可的最初设置也就创建了。组合通过从三个方面做出特定的请求可以优化这些许可：

    * 第一方面是指定为了使组合运行它必须拥有的最小许可设置。如果这些许可没有给予，那么组合将不同调入到内存，并抛出例外。
    * 第二，可以指定一组可选的许可。尽管组合希望存在这些许可，但如果无法获得这些许可，它仍可以调入到内存。
    * 最后，行为特别好的组合实际上会拒绝它们所不需的有风险的许可。这三个优化选项是调入时作为声明语句实现的。 

在运行时，许可是根据代码的执行计算的。右侧的图总结了这个过程的发生顺序。组合A3将它的证据和来自主机的证据提供给策略评估器。策略评估器在创建许可时也要考虑从组合得到的许可请求，“G3”。组合A3由组合A2调用，而A2又是由组合A1调用的。当组合 A3执行一个引发安全检查的操作时，A2和A1获得的许可同样也要进行检查，以确保它们拥有A3所请求的许可权限。在这个过程中，此过程称为堆栈遍历（walking），堆栈中每个组合的许可权限都要进行检查以确定所给予的权限设置是否包含安全检查所需要的许可。如果堆栈中的每个组合被给予了安全检查所需要的许可，调用将成功。如何任何组合没有给予所需要的许可，堆栈遍历过程失败，安全例外将被抛出。


图 1.主机和组合为策略评估器提供证据，评估器使用安全策略和许可请求确定组合的许可权限。应用程序中不同运行组件的许可权限然后用于作出授权决定。

代码访问安全堆栈遍历可以保护代码不受攻击。在精通的攻击中，恶意代码欺骗受信任代码执行它独自不能运行的操作--有效地利用代码的许可权限实现恶意的目的。对这类攻击，开发人员很难进行防备--但堆栈遍历确保了如果涉及到了低级信任等级的代码，有效许可将被减少到信任等级最低的代码具有的许可。

结果，代码将从源处获得不同的信任等级，并在适合于特定的代码执行环境的限制下运行。

.NET Framework调用的“自由”安全性
一些活动，如读写文件，显示对话框，读写环境变量，可以通过包含在框架安全构架中的.NET Framework方法实现。这就使.NET Framework能根据安全策略允许或不允许一个操作，而不需要程序员做额外的工作。尽管暴露了保护资源的管理类的创建者在他们的库中做了明确的安全需求，使用.NET Framework类库访问受保护资源的开发人员可以自由地利用代码访问安全系统；他们不必作出明确的安全调用。

管理员可以通过决定给予哪些许可来优化安全策略，然后，依靠.NET Framework处理所有的安全操作。代码访问安全能阻止大部分的恶意攻击，对代码的验证减少了缓存溢出和其它会导致安全攻击的不期望的行为。因此，应用程序和组件生来就受到了保护，它们免于大多数安全问题的冲击，而这些安全问题一直困绕着本地代码的实现。

基于角色的安全
有时根据已认证的身份或根据与代码执行上下文相关的角色作出认证决定是合适的。例如，金融和企业软件可以通过评估角色信息的企业逻辑加强策略。根据作出请求的用户角色可以对金融交易的数据进行限制。出纳被允许可以处理一定金额的请求，而多于该金额的所有工作需要监督人的角色来处理。

身份可以映射到登录系统的用户，或由应用程序定义。相应的原则封装了身份和其它相关的角色信息（例如，但并不限于此，用户的“组”由操作系统定义）。

认证和授权
认证是一个过程，它接收来自用户的证书，并对证书的授权进行确认。如果证书是有效的，那么用户就可以说他拥有已认证的身份。而授权的过程是：确定认证用户是否能够访问给定的资源。认证可通过系统或企业逻辑来完成，通过某个API它是或获得的。认证API是完全可扩展的，因此开发人员根据需要使用自己的企业逻辑。开发人员可以对他们的认证需求进行编码，也可以修改底层的认证方法而无需对他们的代码作太大变化。除了微软Windows?操作系统身份认证外，还有的认证方法包括基本HTTP，摘要和 Kerberos，以及微软Passport和基于窗体的认证。这些认证方法已经完全集成到ASP.NET中了。

在ASP.NET窗体认证中，用户提供证书，并提交窗体。如果应用程序簦别请求，系统发送一个cookie ，该cookie以某种形式包含包含了证书或包含重新获得身份的关键字。接下来发送的请求在头中包含了cookie，ASP.NET处理程序通过应用程序所期望的任何有效方法对这些请求认证和授权。如果请求没有经过认证，HTTP客户端将用于把请求发送到认证窗体，在那里用户可能提供信任证书。窗体认证有时用于个性化--为已知用户的内容进行定置。在一些情况下，身份是问题所在而不是认证，因此用户的个性化信息可以简单地通过访问用户或获得。

授权的目的是确定作出请求的身份是否被给予了对给定资源的访问权。ASP.NET提供了两种类型的授权服务：文件授权和URL授权。文件授权根据正在作用的方法和作出请求的身份决定用户使用于哪个访问控制列表。URL授权是URI名称空间和不同用户或角色间的逻辑映射。

隔离存储
.NET Framework提供了一个特殊的功能，隔离存储，用于存储数据，甚至是当不允许对文件进行访问时--例如，当从Internet下载了一个管理控件，并运行它，为它提供了有限的许可权但没有权力读写文件。

隔离存储是一组新的用于.NET支持的用于本地存储的类型和方法。在本质上，每个组合可以访问磁盘上一断被隔离的存储空间。它不允许访问其它数据，隔离存储只对为它创建的组合有效。

隔离存储也可被应用程序用于保存活动记录，保存设置，或者将状态数据保存到磁盘上以备将来之用。因为隔离存储的位置是预先决定好的，所以隔离存储为指定唯一存储空间提供了一种方便的方式，而不需要决定文件路径。

从本地企业局域网获得的代码具有相似的限制，但更少，它可以访问大限额的隔离存储。最后，从受限站点区域（不信任站点）来的代码没有对隔离存储的访问权。

加密
.NET Framework提供了一组加密对象，它们支持加密算法、数字签名、散列、生成随机数，是通过众所周知的运算法则实现的，如RSA, DSA, Rijndael/AES, Triple DES, DES, 和 RC2, 以及MD5, SHA1, SHA-256, SHA-384 和 SHA-512散列算法。同时还支持在IETF和W3C开发的XML数字签名规范。.NET Framework使用加密对象支持内部服务。这些对象还作为管理代码提供给需要加密支持的开发人员。


如何指定安全性？

如果要对组合运行时的行为进行修改，根据程序员的需要，可以作出声明式安全或强迫式安全的修改。

声明式安全
声明式安全使程序员可以直接在组合代码的元数据中为组合指定安全需求。许可请求和所有其它形式的声明式安全是在代码中是作为定置属性指定的。类，属性和方法的注释用于优化许可。例如，声明式安全可用于类的调用者在调用方法前检查调用者是否被已知地行商签名过，或有一个特定的强名。

由于声明属性是组合元数据的一部分，所以组合的安全需求易于辨别。可以使用工具对组合进行扫描，以发现哪些方法需要某些许可，哪些方法断言了某些许可。

当被请求的活动和许可在编译时是知道时，声明式检查可作为选择的解决方案之一。例如，如果方法总是检查对C:\temp的写访问许可，那么许可检查就会从声明中得到好处。另一方面，如果被请求的具有访问权的位置发生了变化，那么强迫式安全也许是一个比较好的解决方案。

强迫式安全
强迫式安全直接在代码中实现。程序员通过程序采取安全活动，并且根据安全堆栈的状态决定是给予还是拒绝许可。例如，当一个方法请求访问一个特定的文件时，如果调用者（或方法的任何一个调用者）没有被给予必需的许可权限，那么请求失败。因为强迫式安全是通过程序实现的，所以满足了动态需求。如果你需要对一个特定文件的访问许可，但该许可还要根据其它信息发生变化，那么，强迫式安全就是可选的解决方案。


总结

.NET Framework安全迎合了这种事实：软件向多样化的移动组件发发展，并根据这种事实提供保护。在一个细化的、可扩展的策略和许可系统下，用户能够运行功能强大的代码，而同时减少相关的风险。在没有运行时对用户作出信任决定时，管理员可以在各个级别创建强壮的安全策略。策略是完全可定置的。开发人员能够集中解决应用程序逻辑，而不用关心核心的安全问题（它由CLR透明地处理）。然而，开发人员可以在任何时候扩展安全模型。
